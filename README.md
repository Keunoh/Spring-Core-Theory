# Spring-Core
# 🎇스프링의 진짜 핵심
- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- 스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크

### 다형성 
- 역할과 구현으로 세상을 구분
- `클라이언트에 영향을 주지 않고` 새로운 기능을 줄 수 있다.
  - 예시
    - 운전자 / 자동차
    - 공연 무대
    - 키보드, 마우스 등
  - 역할과 구현을 분리
    - 역할과 구현으로 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.
    - 장점
      - `클라이언트`는 대상의 역할(인터페이스)만 알면 된다.
      - `클라이언트`는 구현 대상의 `내부 구조를 몰라도` 된다.
      - `클라이언트`는 구현 대상의 내부 구조가 변경되어도 영향을 받지 않는다.
      - `클라이언트`는 구현 대상 자체를 변경해도 영향을 받지 않는다.
  - 자바 언어의 다형성을 활용
    - 역할 = 인터페이스
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체
    - 객체를 설계할 때 역할과 구현을 명확히 분리
    - 객체 설계시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
  - 다형성의 본질
    - 인터페이스를 구현한 객체 인스턴스를 `실행 시점`에 `유연`하게 `변경`할 수 있다.
    - 다형성의 본질을 이해하려면 `협력`이라는 객체 사이의 관계에서 시작해야함
    - `클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.`
  - 한계
    - 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생
    - 만약 자동차 역할을 비행기 역할로 변경해야 한다면?
    - 연극 대본 자체가 변경되어야 한다면?
    - USB 인터페이스가 변경된다면?

### 스프링과 객체 지향
- 다형성이 가장 중요하다!
- 스프링은 다양성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블럭 조립하듯이! 공연 무대의 배우를 선택하듯이! 구현을 편리하게 변경할 수 있다.
---
### ⭐ 역할과 구현으로 구분하는 것이 무엇보다 중요하다.
### ⭐ 좋은 개발 습관은 제약을 두는 것이다.
# SOLID Principle
- 클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리
- SRP : 단일 책임 원칙(Single Responsibility Principle)
- OCP : 개방-폐쇄 원칙(Open/Closed Principle)
- LSP : 리스코프 치환 원칙(Liskov Substitution Principle)
- ISP : 인터페이스 분리 원칙(Interface Segregation Principle)
- DIP : 의존관계 역전 원칙(Dependency Inversion Principle)

1. SRP 단일 책임 원칙  
Single Responsibility Principle
   - *한 클래스는 하나의 책임만 가져야한다.*
   - 하나의 책임이라는 것은 모호하다. 클 수 있고, 작을 수 있다. 문맥과 상황에 따라 다르다.
   - 중요한 기준은 변경이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것이다.
   - 예) UI 변경, 객체의 생성과 사용을 분리

2. OCP 개방-폐쇄 원칙  
Open/Closed Principle
   - *소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.*
   - 다형성을 활용해보자
   - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
   - 지금까지 배운 역할과 구현의 분리를 생각해보자

3. LSP 리스코프 치환 원칙  
Liskov Substitution Principle
   - *프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.*
   - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.
   - 단순히 컴파일에 성공하는 것을 넘어서는 이야기
   - 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야함

4. ISP 인터페이스 분리 원칙  
Interface Segregation Principle
   - *특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.*
   - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
   - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리
   - 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
   - 인터페이스가 명확해지고, 대체 가능성이 높아진다.

5. DIP 의존관계 역전 원칙  
Dependency Inversion Principle
   - *프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안 된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나다.*
   - 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
   - 앞에서 이야기한 `역할(Role)에 의존하게 해야 한다는 것과 같다.` 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.
   - 구현체에 의존하게 되면 변경이 아주 어려워진다.

### 다시 스프링으로
스프링 이야기에 왜 객체 지향 이야기가 나오는가?
- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
  - DI(Dependency Injection) : 의존관계, 의존성 주입
  - DI 컨테이너 제공
- `클라이언트 코드의 변경 없이 기능 확장`
- 쉽게 부품을 교체하듯이 개발

스프링이 없던 시절로
- 옛날 어떤 개발자가 좋은 객체 지향 개발을 하려고 OCP, DIP 원칙을 지키면서 개발을 해보니, 너무 할일이 많았다. 배보다 배꼽이 크다. 그래서 프레임워크로 만들어버림
- 순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다. (더 정확히는 DI 컨테이너)
- DI 개념은 말로 설명해도 이해가 잘 안된다. 코드로 짜봐야 필요성을 알게된다!
실무고민
- 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩토링해서 인터페이스를 도입하는 것도 방법이다.
---
# 🎭 관심사의 분리
- 애플리케이션을 하나의 공연이라 생각해보자. 각각의 인터페이스를 배역(배우 역할)이라 생각하자. 그런데! 실제 배역 맞는 배우를 선택하는 것은 누가 하는가?
- 로미오와 줄리엣 공연을 하면 로미오 역할을 누가 할지 줄리엣 역할을 누가 할지는 배우들이 정하는게 아니다. 이전 코드는 마치 로미오 역할(인터페이스)을 하는 레오나르도 디카프리오(구현체, 배우)가 줄리엣 역할(인터페이스)을 하는 여자 주인공(구현체, 배우)을 직접 초빙하는 것과 같다. 디카프리오는 공연도 해야하고 동시에 여자 주인공도 공연데 직접 초빙해야 하는 `다양한 책임`을 가지고있다.
- 관심사를 분리하자
  - 배우는 본인의 역할인 배역을 수행하는 것에만 집중해야 한다.
  - 디카프리오는 어떤 여자 주인공이 선택되더라도 똑같이 공연할 수 있어야 한다.
  - 공연을 구성하고, 담당 배우를 섭외하고, 역할에 맞는 배우를 지정하는 책임을 담당하는 별도의 `공연 기획자`가 나올시점이다.
  - 공연 기획자를 만들고, 배우와 공연 기획자의 책임을 확실히 분리하자

### AppConfig 등장
- 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, `구현 객체를 생성`하고, `연결`하는 책임을 가지는 별도의 설정 클래스를 만들자.

### IoC, DI, Container 🕋 -> 🪑🚪🧳
1. 제어의 역전 IoC(Inversion of Control)
   - 기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 한 마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다. 개발자 입장에서는 자연스러운 흐름이다.
   - 반면에 AppConfig가 등장한 이후에 구현 객체는 자신이 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다. 예를들어서 'OrderServiceImpl'은 필요한 인터페이스들을 호출하지만 어떤 구현 객체들이 실행될지 모른다.
   - 프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 'OrderServiceImpl'도 AppConfig가 생성한다. 그리고 AppConfig는 'OrderServiceImpl'이 아닌 OrderService 인터페이스의 다른 구현 객체를 생성하고 실행할 수도 있다. 그런 사실도 모른체 'OrderServiceImpl'은 묵묵히 자신의 로직을 실행할 뿐이다.
   - 이렇듯 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)이라고 한다.

2. 의존관계 주입 DI(Dependency Injection)
   - 'OrderServiceImpl'은 'DiscountPolicy' 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는 모른다.
   - 의존관계는 `정적인 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계`들을 분리해서 생각해야 한다.

   1. `정적인 클래스 의존 관계`
      - 클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.

   2. `동적인 객체 인스턴스 의존 관계`
      - 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.
      - 애플리케이션 '실행 시점(런타임)'에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 '의존관계 주입'이라한다.
      - 객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.
      - 의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.
      - 의존관계 주입을 사용하면 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.

3. IoC 컨테이너, DI 컨테이너
   - AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC컨테이너 또는 `DI 컨테이너`라 한다.
   - 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.
   - 또는 어셈블러, 오브젝트 팩토리 등으로 불리기도 한다.
---
### Singleton Container and Pattern 🎲 🗃
1. Singleton Container
   - 웹 애플리케이션 싱글톤
   - 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
   - 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수 있다.
   - 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.

2. Singleton Pattern
   - 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
   - 그래서 객체 인스턴스를 2개 이상 생성하지 못 하도록 막아야 한다.
   - private 생성자를 사용해서 외부에서 임의로 new를 막아야한다.

3. Singleton Container의 장점과 주의점(실무에서 중요)
   1. `장점`
      - 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다. 지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.
      - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다. 이전에 설명한 컨테이너 생성 과정을 자세히 보자. 컨테이너는 객체를 하나만 생성해서 관리한다.
      - 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.
      - 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
   2. `주의점`
      - 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태 유지(stateful)하게 설계하면 안 된다.
      - 무상태(stateless)로 설계해야한다.
      - 특정 클라이언트에 의존적인 필드가 있으면 안 된다.
      - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안 된다.
      - 가급적 읽기만 가능해야 한다.
      - 필드 대신에 자바에서 공유되지 않은, 지역변수, 파라미터, ThreadLocal등을 사용해야 한다.
      - 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.
---
### 스프링 빈 설정 메타 정보 - Bean Definition
- 스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까? 그 중심에는 `Bean Definition`이라는 추상화가 있다.
- 쉽게 이야기해서 *역할과 구현을 개념적으로 나눈 것*이다!
  - XML을 읽어서 BeanDefinition을 만들면 된다.
  - 자바 코드를 읽어서 BeanDefinition을 만들면 된다.
  - 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 된다. 오직 BeanDefinition만 알면 된다.
- `BeanDefinition`을 빈 설정 메타정보라 한다.
  - `@Bean`, `<bean>`당 각각 하나씩 메타 정보가 생성된다.
- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
---
# 🎲 웹 애플리케이션과 싱글톤
- 스프링은 태생이 기업용 온라인 서비스 기술을 지원하기 위해 탄생했다.
- 대부분의 스프링 애플리케이션은 웹 애플리케이션이다. 물론 웹이 아닌 애플리케이션 개발도 얼마든지 개발할 수 있다.
- 웹 애플리케이션은 보통 여러 고객이 동시에 요청을 한다.
- 우리가 만들었던 스프링 없는 순수한 DI 컨테이너인 AppConfig는 요청을 할 때 마다 객체를 새로 생성한다.
- 고객 트래픽이 초당 100이 나오면 초당 100개 객체가 생성되고 소멸된다! -> 메모리 낭비가 심하다.
- 해결방안은 해당 객체가 딱 1개만 생성되고, 공유하도록 설계하면 된다. -> 싱글톤 패턴

### 싱글톤 패턴
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못 하도록 막아야 한다.
  - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못 하도록 막아야 한다.
  1. static 영역에 객체 instance를 미리 하나 생성해서 올려준다.
  2. 이 객체 인스턴스가 필요하면 오직 `getInstance()`메서드를 통해서만 조회할 수 있다. 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.
  3. 딱 1개의 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 혹시라도 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.
- *싱글톤 패턴 문제점*
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존한다. -> DIP를 위반한다.
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
  - 테스트하기 어렵다.
  - 내부 속성을 변경하거나 초기화하기 어렵다.
  - private 생성자로 자식클래스를 만들기 어렵다.
  - 결론적으로 유연성이 떨어진다.
  - 안티패턴으로 불리기도 한다.

### 싱글톤 컨테이너
스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.
지금까지 우리가 학습한 스프링 빈이 바로 싱글톤으로 관리되는 빈이다.
- *싱글톤 컨테이너*
  - 스프링 컨테이너는 싱글톤 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.
    - 이전에 설명한 컨테이너 생성 과정을 자세히 보자. 컨테이너는 객체를 하나만 생성해서 관리한다.
  - 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라고 한다.
  - 스프링 컨테이너의 이런 기능 덕분에 싱글톤 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.
    - 싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.
    - DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.
  - 스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유해서 효율적으로 재사용할 수 있다.
  - 참고 : 스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다. 자세한 내용은 뒤에 빈 스코프 참고

### 싱글톤 방식의 주의점
- 싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안 된다.
- 무상태(stateless)로 설계해야 한다!
  - 특정 클라이언트에 의존적인 필드가 있으면 안 된다.
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안 된다!
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다!!!

### @Configuration과 바이트코드 조작의 마법
스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그런데 스프링이 자바 코드까지 어떻게 하기는 어렵다.
자바 코드를 보면 분명 3번 호출되어야 하는 것이 맞다. 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.
모든 비밀은 `@Configuration`을 적용한 `AppConfig`에 있다.
순수한 클래스라면 다음과 같이 출력되어야 한다. `class hello.core.AppConfig`
그런데 예상과는 다르게 클래스 명에 xxxCGLIB가 붙으면서 상당히 복잡해진 것을 볼 수 있다.
이것은 내가 만든 클래스가 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은
임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것이다!
- @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
- 덕분에 싱글톤이 보장되는 것이다.
- *참고* AppConfig@CGLIB는 AppConfig의 자식 타입이므로, AppConfig 타입으로 조회할 수 있다.
---
### Component Scan - 탐색 위치와 기본 스캔 대상
- 탐색할 패키지의 시작 위치 지정
- 모든 자바 클래스를 다 컴포넌트 스캔하면 시간이 오래 걸린다. 그래서 꼭 필요한 위치부터 탐색하도록 시작 위치를 지정할 수 있다.
- `basePackages` : 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한다.
  - `basePackages = {"hello.core", "hello.service"}` 이렇게 여러 시작 위치를 지정할 수도 있다.
- `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다.
- 만약 지정하지 않으면 `@ComponentScan`이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.

- *권장하는 방법*
  <p>개인적으로 즐겨 사용하는 방법은 패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것이다.
     최근 스프링 부트도 이 방법을 기본으로 제공한다.
  </p>
- 예를 들어서 프로젝트가 다음과 같이 구조가 되어 있으면
  - `com.hello`
  - `com.hello.service`
  - `com.hello.repository`
- `com.hello` -> 프로젝트 시작 루트, 여기에 AppConfig 같은 메인 설정 정보를 두고, @ComponentScan 애노테이션을 붙이고, `basePackages` 지정은 생략한다.
<p>
이렇게 하면 `com.hello`를 포함한 하위는 모두 자동으로 컴포넌트 스캔의 대상이 된다.
그리고 프로젝트 메인 설정 정보는 프로젝트를 대표하는 정보이기 때문에 프로젝트 시작 루트 위치에 두는 것이 좋다 생각한다.
참고로 스프링 부트를 사용하면 스프링 부트의 대표 시작 정보인 `@SpringBootApplication`를 이 프로젝트 시작 루트 위치에 두는 것이 관례이다.
(그리고 이 설정안에 바로 `@ComponentScan`이 들어있다!)
</p> 

### ⭐ 개발할 때 어설픈 추상화나 어설픈 코드 줄이기 보다 코드를 좀 더 쓰더라도(중복이 있더라도) 명확한 것이 훨씬 더 좋은 선택이다.

---
# 💉 Various Dependency Injection Ways 
스프링 라이프 사이클에서 스프링 빈을 등록하는 단계랑 스프링 의존관계를 주입하는 단계가 구분되어있다.
- 생성자 주입
- 수정자 주입(setter 주입)
- 필드 주입
- 일반 메서드 주입

1. 생성자 주입
   - 이름 그대로 생성자를 통해서 의존관계를 주입 받는 방법이다.
   - 지금까지 우리가 진행했던 방법이 바로 생성자 주입이다.
   - 특징
     - 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
     - `* 불변, 필수 *` 의존관계에 사용
     - 클래스 내의 생성자가 딱 1개일 경우는 @Autowired를 생략해도 된다.

2. 수정자 주입(setter 주입)
   - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법이다.
   - 특징
     - `* 선택, 변경 *` 가능성이 있는 의존관계에 사용
     - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.

3. 필드 주입
   - 이름 그대로 필드에 바로 주입하는 방법이다.
     (* 안티 패턴)
   - 특징
     - 코드가 간결해서 많은 개발자들을 유혹하지만 외부에서 변경이 불가능해서 테스트하기 힘들다는 치명적인 단점이 있다.
     - DI 프레임워크가 없으면 아무것도 할 수 없다.
     - 사용하지말자!
       - (예외) 애플리케이션의 실제 코드와 관계 없는 테스트 코드에선 사용 가능
       - (예외) 스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용

4. 일반 메서드 주입
   - 일반 메서드를 통해서 주입 받을 수 있다.
   - 특징
     - 한번에 여러 필드를 주입 받을 수 있다.
     - 일반적으로 잘 사용하지 않는다.

참고 : 어쩌면 당연한 이야기이지만 의존관계 자동 주입은 스프링 컨테이너가 관리하는 스프링 빈이어야 동작한다.
스프링 빈이 아닌 `Member` 같은 클래스에서 `@Autowired` 코드를 적용해도 아무 기능도 동작하지 않는다.

### 생성자 주입을 선택해라!
과거에는 수정자 주입과 필드 주입을 많이 사용했지만, 최근에는 스프링을 포함한 DI Framework 대부분이 생성자 주입을 권장한다. 그 이유는 다음과 같다.
- `불변`
- `누락`
- `fianl keyword`

1. 불변
   - 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안 된다.(불변해야한다)
   - 수정자 주입을 사용하면, setXxxx 메서드를 public으로 열어두어야 한다.
   - 누군가 실수로 변경할 수도 있고, 변경하면 안 되는 메서드를 열어두는 것은 좋은 설계 방법이 아니다.
   - 생성자 주입은 객체를 생성할 때 딱 1번만 호출되므로 이후에 호출되는 일이 없다. 따라서 불변하게 설계할 수 있다.

2. 누락
   - 생성자 주입을 사용하면 테스트 코드에서 주입 데이터를 `누락`했을 때 `컴파일 오류`가 발생한다.

3. final keyword
   - 생성자 주입을 사용하면 필드에 `final` 키워드를 사용할 수 있다. 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다.
   - `final` -> 이 의미는 생성자로만 값을 입력해주거나 처음에 수동으로만 값을 입력해 줄 수 있기 때문에 `불변`이다.

4. 📋 Conclusion
   - `참고`
     - 기억하자! `🌟컴파일 오류는 세상에서 가장 빠르고, 좋은 오류다!`
     - 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 `final` 키워드를 사용할 수 없다. 오직 생성자 주입 방식만 `fianl` 키워드를 사용할 수 있다.
   - 생성자 주입 방식을 선택하는 이유는 여러가지가 있지만, 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이기도 하다.
   - 기본으로 생성자 주입을 사용하고, 필수 값이 아닌 경우에는 수정자 주입 방식을 옵션으로 부여하면 된다. 생성자 주입과 수정자 주입을 동시에 사용할 수 있다.
   - 항상 생성자 주입을 선택하라! 그리고 가끔 옵션이 필요하면 수정자 주입을 선택하라. 필드 주입은 사용하지 않는게 좋다.

### 롬복과 최신 트랜드
막상 개발을 해보면, 대부분이 다 불변이고, 그래서 다음과 같이 생성자에 final 키워드를 사용하게 된다.
그런데 생성자도 만들어야 하고, 주입 받은 값을 대입하는 코드도 만들어야 하고...
필드 주입처럼 좀 편리하게 하는 사용 방버은 없을까?
역시 개발자는 귀찮은 것은 못 참는다!
- 롬복 라이브러리가 제공하는 `@RequiredArgsConstructor` 기능을 사용하면 final이 붙은 필드를 모아서 생성자를 자동으로 만들어준다. (다음 코드에는 보이지 않지만 실제 호출 가능하다.)
- 롬복이 자바의 애노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 생성자 코드를 자동으로 생성해준다. 실제 `class`를 열어보면 다음 코드가 추가되어 있는 것을 확인할 수 있다.

### 조회 - 빈이 2개 이상 문제
스프링 빈 조회에서 학습했듯이 타입으로 조회하면 선택된 빈이 2개 이상일 때 문제가 발생한다.
`DiscountPolicy`의 하위타입인 `FixDiscountPolicy`, `RateDiscountPolicy` 둘다 스프링 빈으로 선언해보자.
오류메시지가 친절하게도 하나의 빈을 기대했는데 `fixDiscountPolicy`, `RateDiscountPolicy` 2개가 발견되었다고 알려준다.
이때 하위 타입으로 지정할 수도 있지만, 하위 타입으로 지정하는 것은 DIP를 위배하고 유연성이 떨어진다.
그리고 이름만 다르고, 완전히 똑같은 타입의 스프링 빈이 2개 있을 때 해결이 안 된다.
스프링 빈을 수동 등록해서 문제를 해결해도 되지만, 의존 관계 자동 주입에서 해결하는 여러 방법이 있다.

### @Autowired 필드명, @Qualifier, @Primary
조회 대상 빈이 2개 이상일 때 해결 방법
- @Autowired 필드명 매칭
- @Qualifier -> @Qualifier 끼리 매칭 -> 빈 이름 매칭
- @Primary 사용

1. @Autowired 필드명 매칭
   - `@Autowired`는 타입 매칭을 시도하고, 이때 여러 빈이 있으면 필드 이름, 파라미터 이름으로 빈 이름을 추가 매칭한다.
   - `*필드명 매칭은 먼저 타입 매칭을 시도하고 그 결과에 여러 빈이 있을 때 추가로 동작하는 기능이다.*`
   - *@Autowired 매칭 정리*
     - 타입 매칭
     - 타입 매칭의 결과가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭

2. @Qualifier 사용
   - `@Qualifer`는 추가 구분자를 붙여주는 방법이다. 주입 시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아니다.
   - `*빈 등록시 @Qualifier를 붙여 준다.*`
   - `*주입시에 @Qualifier를 붙여주고 등록한 이름을 적어준다.*`
   - `@Qualifer`로 주입할 때 `@Qualifer("mainDiscountPolicy")`를 못 찾으면 어떻게 될까? 그러면 mainDiscountPolicy라는 이름의 스프링 빈을 추가로 찾는다. 하지만 경험상 `@Qualifier`는 `@Qualifier`를 찾는 용도로만 사용하는게 명확하고 좋다.
   - *@Qualifer 정리*
     - @Qualifier끼리 매칭
     - 빈 이름 매칭
     - `NoSuchBeanDefinitionException` 예외 발생

3. @Primary 사용
   - `@Primary`는 우선순위를 정하는 방법이다. @Autowired 시에 여러 빈이 매칭되면 `@Primary`가 우선권을 가진다.

여기까지 보면 `@Primary`와 `@Qualifier` 중에 어떤 것을 사용하면 좋을지 고민이 될 것이다. 
`@Qualifier`의 단점은 주입 받을 때 다음과 같이 모든 코드에 `@Qualifier`를 붙여주어야 한다는 점이다.

*@Primary, @Qualifier 활용*   
코드에서 자주 사용하는 메인 데이터베이스의 커넥션을 획득하는 스프링 빈이 있고, 코드에서 특별한 기능으로 가끔 사용하는 서브 데이터베이스의 커넥션을 획득하는 스프링 빈이 있다고 생각해보자.
메인 데이터베이스의 커넥션을 획득하는 스프링 빈은 `@Primary`를 적용해서 조회하는 곳에서 `@Qualifier`지정 없이 편리하게 조회하고, 
서브 데이터베이스 커넥션 빈을 획득할 때는 `@Qualifier`를 지정해서 명시적으로 획득하는 방식으로 사용하면 코드를 깔끔하게 유지할 수 있다.
물론 이때 메인 데이터베이스의 스프링 빈을 등록할 때 `@Qualifier`를 지정해주는 것은 상관 없다.

*우선순위*   
`@Primary`는 기본값처럼 동작하는 것이고, `@Qualifier`는 매우 상세하게 동작한다.
이런 경우 어떤 것이 우선권을 가져갈까?
스프링은 자동보다는 수동이, 넓은 범위의 선택권보다는 좁은 범위의 선택권이 우선 순위가 높다.
따라서 여기서도 `@Qualifier`가 우선권이 높다.

#### 로직분석 
    - DiscountService는 Map으로 모든 `DiscountPolicy`를 주입받는다.
    이때 `fixDiscountPolicy`, `rateDiscountPolicy`가 주입된다.
    - `discount ()` 메서드는 discountCode로 "fixDiscountPolicy"가 넘어오면
    map에서 `fixDiscountPolicy` 스프링빈을 찾아서 실행한다.
    물론 "rateDiscountPolicy"가 넘어오면 `fixDiscountPolicy` 스프링 빈을 찾아서
    실행한다.

#### 주입분석
    - `Map<String, DiscountPlicy>` : map의 키에 스프링 빈의 이름을 넣어주고,
    그 값으로 `DiscountPolicy` 타입으로 조회한 모든 스프링 빈을 담아준다.
    - `List<DiscountPolicy>` : `DiscountPolicy` 타입으로 조회한 모든 스프링
    빈을 담아준다.
    만약 해당하는 타입의 스프링 빈이 없으면, 빈 컬렉션이나 Map을 주입한다.

### "자동, 수동의 올바른 실무 운영 기준"
- *편리한 자동 기능을 기본으로 사용하자*
    - 그러면 어떤 경우에 커모넌트 스캔과 자동 주입을 사용하고, 어떤 경우에 설정 정보를 통해서 수동으로 빈을 등록하고, 의존관게도 수동으로 주입해야 할까?
    - 결론부터 이야기하면, 스프링이 나오고 시간이 갈수록 점점 더 자동을 선호하는 추세다. 스프링은 `@Component` 뿐만 아니라 `@Controller`, `@Service`, `@Repository`처럼 계층에 맞추어 일반적인 애플리케이션 로직을 자동으로 스캔할 수 있도록 지원한다. 거기에 더해서 최근 스프링 부트는 컴포넌트 스캔을 기본으로 사용하고, 스프링 부트의 다양한 스프링 빈들도 조건이 맞으면 자동으로 등록하도록 설게했다.
    - 설정 정보를 기반으로 애플리 케이션을 구성하는 부분과 실제 동작하는 부분을 명확하게 나누는 것이 이상적이지만, 개발자 입장에서 스프링 빈을 하나 등록할 때 `@Component`만 넣어주면 끝나는 일을 `@Configuration` 설정 정보에 가서 `@Bean`을 적고, 객체를 생성하고, 주입할 대상을 일일이 적어주는 과정은 상당히 번거롭다. 또 관리할 빈이 많아서 설정 정보가 커지면 설정 정보를 관리하는 것 자체가 부담이 된다. 그리고 결정적으로 자동 빈 등록을 사용해도 OCP, DIP를 지킬 수 있다.
- *그러면 수동 빈 등록은 언제 사용하면 좋을까?*
  - 애플리케이션은 크게 업무로직과 기술 지원 로직으로 나눌 수 있다.
    - "업무 로직 빈" : 웹을 지원하는 컨트롤러, 핵심 비즈니스 로직이 있는 서비스, 데이터 계층의 로직을 처리하는 리포지토리 등이 모두 업무 로직이다. 보통 비즈니스 요구사항을 개발할 때 추가되거나 변경된다.
    - "기술 지원 빈" : 기술적인 문제나 공통 관심사(AOP)를 처리할 때 주로 사용된다. 데이터베이스 연결이나 공통 로그 처리처럼 업무 로직을 지원하기 위한 하부 기술이나 공통 기술들이다.
    - 업무 로직은 숫자도 매우 많고, 한번 개발해야 하면 컨트롤러, 서비스, 리포지토리처럼 어느 정도 유사한 패턴이 있다. 이런 경우 자동 기능을 적극 사용하는 것이 좋다. 보통 문제가 발생해도 어떤 곳에서 문제가 발생했는지 명확하게 파악하기 쉽다.
    - 기술 지원 로직은 업무 로직과 비교해서 그 수가 매우 적고, 보통 애플리케이션 전반에 걸쳐서 광범위하게 영향을 미친다. 그리고 업무 로직은 문제가 발생했을때 어디가 문제인지 명확하게 잘 드러나지만, 기술 지원 로직은 적용이 잘 되고 있는지 아닌지 조차 파악하기 어려운 경우가 많다. 그래서 이런 기술 지원 로직들은 가급적 수동 빈 등록을 사용해서 명확하게 드러내는 것이 좋다.
- "애플리케이션에 광범위하게 영향을 미치는 기술 지원 객체는 수동 빈으로 등록해서 딱! 설정 정보에 바로 나타나게 하는 것이 유지 보수하기 좋다."
- 비즈니스 로직 중에서 다형성을 적극 활용할 때
  - 의존관계 자동 주입 - 조회한 빈이 모두 필요할 떄, List, Map을 다시 보자. `DiscountService`가 의존관계 자동 주입으로 `Map<String, DiscountPolicy>` 에 주입을 받는 상황을 생각해보자. 여기에 어떤 빈들이 주입될 지, 각 빈들의 이름은 무엇인지 코드만 보고 한번에 쉽게 파악할 수 있을까? 내가 개발했으니 크게 관계가 없지만, 만약 이 코드를 다른 개발자가 개발해서 나에게 준것이라면 어떨까? 자동 등록을 사용하고 있기 떄문에 파악하려면 여러 코드를 찾아봐야 한다.
  - 이런 경우 수동 빈으로 등록하거나 또는 자동으로 하면 *특정 패키지에 같이 묶어*두는 게 좋다! 핵심은 딱 보고 이해가 되어야 한다!
  - 이 설정 정보만 봐도 한눈에 빈의 이름은 물론이고, 어떤 빈들이 주입될지 파악할 수 있다. 그래도 빈 자동 등록을 사용하고 싶으면 파악하기 좋게 `DiscountPolicy`의 구현 빈들만 따로 모아서 특정 패키지를 모아두자.
  - 참고로 *스프링과 스프링 부트가 자동으로 등록하는 수 많은 빈들은 예외*다. 이런 부분들은 스프링 자체를 잘 이해하고 스프링의 의도대로 잘 사용하는게 중요하다. 스프링 부트의 경우 `DataSource`같은 데이터베이스 연결에 사용하는 기술 지원로직까지 내부에서 자동으로 등록하는데, 이런 부분은 매뉴얼을 잘 참고해서 스프링 부트가 의도한 대로 편리하게 사용하면 된다. 반면에 *스프링 부트가 아니라 내가 직접 기술 지원객체를 스프링 빈으로 등록한다면 수동으로 등록해서 명확하게 드러내는 것이 좋다.*

#### 정리
    편리한 자동 기능을 기본으로 사용하자
    직접 등록하는 기술 지원 객체는 수동 등록
    다형성을 적극 활용하는 비즈니스 로직은 수동 등록을 고민해보자

---
# 🤹 Bean Life Cycle Call Back
데이터베이스 커넥션 풀이나 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요하다.
- 간단하게 외부 네트워크에 미리 연결하는 객체를 하나 생성한다고 가정해보자. 실제로 네트워크에 연결하는 것은 아니고, 단순히 문자만 출력하도록 했다. 이 `NetworkClient`는 애플리케이션 시작 시점에 `connect()`를 호출해서 연결을 맺어두양 하고, 애플리케이션이 종료되면 `disconnect()`를 호출해서 연결을 끊어야 한다.
- 생성자 부분을 보면 url 정보 없이 connect가 호출되는 것을 확인할 수 있다. 너무 당연한 이야기지만 객체를 생성하는 단계에는 url이 없고, 객체를 생성한 다음에 외부에서 수정자 주입을 통해서 `setUrl()`이 호출되어야 url이 존재하게 된다.
- 스프링은 간단하게 다음과 같은 라이프 사이클을 가진다 : "객체 생성" -> "의존관계 주입"
- 스프링 빈은 객체를 생성하고, 의존관계 주입이 다 끝난 다음에야 필요한 데이터를 사용할 수 있는 준비가 완료된다. 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 난 다음에 호출해야 한다. 그런데 개발자가 의존관계 주입이 모두 완료된 시점을 어떻게 알 수 있을까? *스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공*한다. 또한 *스프링은 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 준다.* 따라서 안전하게 종료 작업을 진행할 수 있다.
- 스프링 빈의 이벤트 라이프 사이클
  - "스프링 컨테이너 생성" -> "스프링 빈 생성" -> "의존관계 주입" -> "초기화 콜백" -> "사용" -> "소멸 전 콜백" -> "스프링 종료" 
  - "초기화 콜백" : 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
  - "소멸 전 콜백" : 빈이 소멸되기 직전에 호출"
  
### "객체의 생성과 초기화를 분리하자"
생성자는 필수 정보(파라미터)를 받고, 메모리를 할당해서 객체를 생성하는 책임을 가진다. 반면에 초기화는 이렇게 생성된 값을 활용해서 외부 커넥션을 연결하는 등 무거운 동작을 수행한다. 따라서 생성자 안에서 무거운 작업을 함께 하는 것보다는 객체를 생성하는 부분과 초기화하는 부분을 명확하게 나누는 것이 유지보수 관점에서 좋다. 물론 초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 나을 수 있다.

#### 스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.
    - 인터페이스(InitializingBean, DisposableBean)
    - 설정 정보에 초기화 메서드, 종료 메서드 지정
    - @PostConstruct, @PreDestroy 애노테이션 지원

### *초기화, 소멸 인터페이스*
- 출력 결과를 보면 초기화 메서드가 주입 완료 후에 적절하게 호출된 것을 확인할 수 있다.
- 그리고 스프링 컨테이너의 종료가 호출되자 소멸 메서드가 호출된 것도 확인할 수 있다.
- *초기화, 소멸 인터페이스 단점*
  - 이 인터페이스는 스프링 전용 인터페이스다. 해당 코드가 스프링 전용 인터페이스에 의존한다.
  - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
  - 내가 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.
  - 참고: 인터페이스를 사용하는 초기화, 종료 방법은 스프링 초창기에 나온 방법들이고, 지금은 다음의 더 나은 방법들이 있어서 거의 사용하지 않는다.

### *빈 등록 초기화, 소멸 메서드*
- *설정 정보 사용 특징*
  - 메서드 이름을 자유롭게 줄 수 있다.
  - 스프링 빈이 스프링 코드에 의존하지 않는다.
  - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
- *종료 메서드 추론*
  - `@bean의 destroyMethod` 속성에는 아주 특별한 기능이 있다.
  - 라이브러리는 대부분 `close`, `shutdown`이라는 이름의 종료 메서드를 사용한다.
  - @Bean의 `destroyMethod`는 기본값이 `(inferred)`(추론)으로 등록되어 있다.
  - 이 추론 기능은 `close`, `shutdown`라는 이름의 메서드를 자동으로 호출해준다. 이름 그대로 종료 메서드를 추론해서 호출해준다.
  - 따라서 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.
  - 추론 기능을 사용하기 싫으면 `destoryMethod=""`처럼 빈 공백을 지정하면 된다.

### *애노테이션 @PostConstruct, @PreDestroy*
- *@PostConstruct, @PreDestroy 애노테이션 특징*
  - 최신 스프링에서 가장 권장하는 방법이다.
  - 애노테이션 하나만 붙이면 되므로 매우 편리하다.
  - 패키지를 잘 보면 `javax.annotation.PostConstruct`이다. 스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
  - 컴포넌트 스캔과 잘 어울린다.
  - 유일한 단점은 외부 라이브러리에는 적용하지 못 한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면 @Bean의 기능을 사용하자.

#### 정리
    @PostConstruct, @PreDestroy 애노테이션을 사용하자
    코드를 고칠 수 없는 외부 라이브러리를 초기화, 종료해야 하면 
    `@Bean`의 `initMethod`, `destroyMethod`를 사용하자.

---
# 🔭 빈 스코프란?
지금까지 우리는 스프링 빈이 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때 까지 유지된다고 학습했다.
이것은 스프링 빈이 기본적으로 싱클톤 스코프로 생성되기 때문이다.
스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻한다.
- *스프링은 다음과 같은 다양한 스코프를 지원한다.*
  - *싱글톤*: 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프이다.
  - *프로토타입*: 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프이다.
  - *웹 관련 스코프*
    - *request*: 웹 요청이 들어오고 나갈 때까지 유지되는 스코프이다.
    - *session*: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프이다.
    - *application*: 웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프이다.

### 프로토타입 스코프
싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 스프링 빈을 반환한다.
반면에 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.
- *싱글톤 빈 요청*
  - 1. 싱글톤 스코프의 빈을 스프링 컨테이너에 요청한다.
  - 2. 스프링 컨테이너는 본인이 관리하는 스프링 빈을 반환한다.
  - 3. 이후에 스프링 컨테이너에 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환한다.
- *프로토타입 빈 요청1*
  - 1. 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.
  - 2. 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
- *프로토타입 빈 요청2*
  - 3. 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
  - 4. 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.
- *정리*
  - 여기서 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다. 클라이언트에 빈을 반환하고, 이후 스프링 컨테이너는 생성된 프로토타입 빈을 관리하지 않는다. 프로토타입 빈을 관리할 책임은 프로토타입 빈을 받은 클라이언트에 있다. 그래서 `@PreDestroy` 같은 종료 메서드가 호출되지 않는다.
- *실행결과*
  - 싱글톤 빈은 스프링 컨테이너 생성 시점에 초기화 메서드가 실행되지만, 프로토타입 스코프의 비은 스프링 컨테이너에서 빈을 조회할 때 생성되고, 초기화 메서드도 실행된다.
  - 프로토타입 빈을 2번 조회했으므로 완전히 다른 스프링 빈이 생성되고, 초기화도 2번 실행된 것을 확인할 수 있다.
  - 싱글톤 빈은 스프링 컨테이너가 관리하기 때문에 스프링 컨테이너가 종료될 떄 빈의 종료 메서드가 실행되자만 ,프로토타입 빈은 스프링 컨테이너가 생성과 의존관게 주입 그리고 초기화까지만 관여하고, 더는 관리하지 않는다. 따라서 프로토타입 빈은 스프링 컨테이너가 종료될 떄 `@PreDestroy` 같은 종료 메서드가 전혀 실행되지 않는다.

#### *프로토타입 빈의 특징 정리*
    - 스프링 컨테이너의 요청할 떄 마다 새로 생성된다.
    - 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
    - 종료 메서드가 호출되지 않는다.
    - 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 
    - 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 문제점
스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환한다.
하지만 싱글톤 빈과 함께 사용할 때는 의도한 대로 잘 동작하지 않으므로 주의해야 한다.
- 프로토타입 빈 직접 요청
  - *스프링 컨테이너에 프로토타입 빈 직접 요청1*
    - 1.클라이언트A는 스프링 컨테이너에 프로토타입 빈을 요청한다.
    - 2.스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(*x01*)한다. 해당 빈의 count 필드 값은 0이다.
    - 3.클라이언트는 조회한 프로토타입 빈에 `addCount()`를 호출하면서 count 필드를 +1 한다.
    - 결과적으로 프로토타입 빈(*x01*)의 count는 1이 된다.
  - *스프링 컨테이너에 프로토타입 빈 직접 요청2*
    - 1.클라이언트B는 스프링 컨테이너에 프로토타입 빈을 요청한다.
    - 2.스프링 컨테이너는 프로토타입 빈을 새로 생성해서 반환(*x02*)한다. 해당 빈의 count 필드 값은 0이다.
    - 3.클라이언트는 조회한 프로토타입 빈에 `addCount()`를 호출하면서 count 필드를 +1 한다.
    - 결과적으로 프로토타입 빈(*x02*)의 count는 1이 된다.
  - *싱글톤에서 프로토타입 빈 사용1*
    - `clientBean`은 싱글톤이므로, 보통 스프링 컨테이너 생성 시점에 함께 생성되고, 의존관계 주입도 발생한다.
    - 1.`clientBean`은 의존관계 자동 주입을 사용한다. 주입 시점에 스프링 컨테이너에 프로토타입 빈을 요청한다.
    - 2.스프링 컨테이너는 프로토타입 빈을 생성해서 `clientBean`에 반환한다. 프로토타입 빈의 count 필드 값은 0이다.
    - 이제 `clientBean`은 프로토타입 빈을 내부 필드에 보관한다. (정확히는 참조값을 보관한다.)
  - *싱글톤에서 프로토타입 빈 사용2*
    - 클라이언트 A는 `clientBean`을 스프링 컨테이너에 요청해서 받는다. 싱글톤이므로 항상 같은 `clientBean`이 반환된다.
    - 3.클라이언트 A는 `clientBean.logic()`을 호출한다.
    - 4.`clientBean`은 prototypeBean의 `addCount()`를 호출해서 프로토타입 빈의 count를 증가한다. count값이 1이 된다.
  - *싱글톤에서 프로토타입 빈 사용3*
    - 클라이언트 B는 `clientBean`을 스프링 컨테이너에 요청해서 받는다. 싱글톤이므로 항상 같은 `clientBean`이 반환된다.
    - *여기서 중요한 점이 있는데, `clientBean`이 내부에 가지고 있는 프로토타입 빈은 이미 과거에 주입이 끝난 빈이다. 주입 시점에 스프링 컨테이너에 요청해서 프로토타입 빈이 새로 생성이 된 것이지, 사용할 때마다 새로 생성되는 것이 아니다!*
    - 5.클라이언트 B는 `clientBean.logic()`을 호출한다.
    - 6.`clientBean`은 prototypeBean의 `addCount()`를 호출해서 프로토타입 빈의 count를 증가한다. 원래 1이었으므로 2가 된다.

#### 정리
    스프링은 일반적으로 싱글톤 빈을 사용하므로, 싱글톤 빈이 프로토타입 빈을 사용하게 된다. 
    그런데 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 
    생성되기는 하지만, 싱글톤 빈과 함께 계속 유지되는 것이 문제다.
    아마 언하는 것이 이런 것은 아닐 것이다. 
    프로토타입 빈을 주입 시점에만 새로 생성하는게 아니라, 사용할 때 마다 새로 생성해서
    사용하는 것을 원할 것이다.

- *참고*: 여러 빈에서 같은 프로토타입 빈을 주입 받으면, *주입 받는 시점에 각각 새로운 프로토타입 빈이 생성*된다. 예를 들어서 clientA, clientB가 각각 의존관계 주입을 받으면 각각 다른 인스턴스의 프로토타입 빈을 주입받는다.
  - clientA -> prototypeBean@x01
  - clientB -> prototypeBean@x02
  - 물론 사용할 때 마다 새로 생성되는 것은 아니다.

### 프로토타입 스코프 - 싱글톤 빈과 함께 사용시 Provider로 문제 해결
싱글톤 빈과 프로토타입 빈을 함께 사용할 때, 어떻게 하면 사용할 때마다 항상 새로운 프로토타입 빈을 생성할 수 있을까?
- 실행해보면 `ac.getBean()`을 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.
- 의존관계를 외부에서 주입(DI)받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup(DL)의존관계 조회(탐색)이라 한다.
- 그런데 이렇게 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.
- 지금 필요한 기능은 지정한 프로토타입 빈을 컨테이너에서 대신 찾아주는 딱! DL 정도의 기능만 제공하는 무언가가 있으면 된다.

### ObjectFactory, ObjectProvider
지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 `ObjectProvider`이다.
참고로 과거에는 `ObjectFactory`가 있었는데, 여기에 편의 기능을 추가해서 `ObjectProvider`가 만들어졌다.
- 실행해보면 `prototypeBeanProvider.getObject()`를 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.
- `ObjectProvider`의 `getObject()`를 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다.(*DL*)
- 스프링이 제공하는 기능을 사용하지만, 기능이 단순하므로 단위테스트를 만들거나 mock 코드를 만들기는 훨씬 쉬워진다.
- `ObjectProvider`는 지금 딱 필요한 DL 정도의 기능만 제공한다.
- *특징*
  - ObjectFactory: 기능이 단순, 별도의 라이브러리 필요 없음, 스프링에 의존
  - ObjectProvider: ObjectFactory 상속, 옵션, 스트림 처리 등 편의 기능이 많고, 별도의 라이브러리 필요 없음, 스프링에 의존

### JSR-330 Provider
마지막 방법은 `javax.inject.Provider`라는 JSR-330 자바 표준을 사용하는 방법이다.
이 방법을 사용하려면 `javax.inject:javax.inject:1`라이브러리를 gradle에 추가해야 한다.
- 실행해보면 `provider.get()`을 통해서 항상 새로운 프로토타입 빈이 생성되는 것을 확인할 수 있다.
- `provider`의 `get()`을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다 (*DL*)
- 자바 표준이고, 기능이 단순하므로 단위테스트를 만들거나 mock 코트를 만들기는 훨씬 쉬워진다.
- `Provider`는 지금 딱 피룡한 DL 정도의 기능만 제공한다.
- *특징*
  - `get()` 메서드 하나로 기능이 매우 단순하다.
  - 별도의 라이브러리가 필요하다.
  - 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.

#### 정리
    - 그러면 프로토타입 빈을 언제 사용할까? 매번 사용할 때마다 의존관계 주입이 완료된 새로운 객체가 필요하면
    사용하면 된다. 그런데 실무에서 웹 애플리케이션을 개발해보면, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기
    때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.
    - `ObjectProvider`, `JSR-330 Provider`등은 프로토타입 뿐만 아니라 DL이 필요한 경우는 언제든지 사용할 수
    있다.

- *참고*
  - 스프링이 제공하는 메서드에 `@Lookup` 애노테이션을 사용하는 방법도 있지만, 이전 방법들로 충분하고 고려해야할 내용도 많아서 생략하겠다.
  - 실무에서 자바 표준인 JSR-330 Provider를 사용할 것인지, 아니면 스프링이 제공하는 ObjectProvider를 사용할 것인지 고민이 될 것이다. ObjectProvider는 DL을 위한 편의 기능을 많이 제공해주고 스프링 외에 별도의 의존관계 추가가 필요없기 때문에 편리하다. 만약(쩡말 그럴일은 거의 없겠지만) 코드를 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 JSR-330 Provider를 사용해야한다.
  - 스프링을 사용하다보면 이 기능 뿐만 아니라 다른 기능들도 자바 표준과 스프링이 제공하는 기능이 겹칠때가 많이 있다. 대부분 스프링이 더 다양하고 편리한 기능을 제공해주기 때문에, 특별히 다른 컨테이너를 사용할 일이 없다면, 스프링이 제공하는 기능을 사용하면 된다.

### 웹 스코프
지금까지 싱글톤과 프로토타입 스코프를 학습했다. 싱글톤은 스프링 컨테이너의 시작과 끝까지 함께하는 매우 긴 스코프이고,
프로토타입은 생성과 의존관계 주입, 그리고 초기화까지만 진행하는 특별한 스코프이다.
- *웹 스코프의 특징*
  - 웹 스코프는 웹 환경에서만 동작한다.
  - 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리한다. 따라서 종료 메서드가 호출된다.
- *웹 스코프 종류*
  - *request*: HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
  - *session*: HTTP Session과 동일한 생명주기를 가지는 스코프
  - *application*: 서블릿 컨텍스트(`ServletContext`)와 동일한 생명주기를 가지는 스코프
  - *websocket*: 웹 소켓과 동일한 생명주기를 가지는 스코프
  
### Request 스코프 예제 개발
동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다.
이럴때 사용하기 딱 좋은 것이 바로 request 스코프이다.
- 로그를 출력하기 위한 `MyLogger` 클래스이다.
- `@Scope(value = "request")`를 사용해서 request 스코프로 지정했다. 이게 이 빈은 HTTP 요청 당 하나씩 생성되고, HTTP 요청이 끝나는 시점에 소멸된다.
- 이 빈이 생성되는 시점에 자동으로 `@PostConstruct`초기화 메서드를 사용해서 uuid를 생성해서 저장해둔다. 이 빈은 HTTP 요청당 하나씩 생성되므로, uuid를 저장해두면 다른 HTTP 요청과 구분할 수 있다.
- 이 빈이 소멸되는 시점에 `@PreDestroy`를 사용해서 종료 메시지를 남긴다.
- `requestURL`은 이 빈이 생성되는 시점에는 알 수 없으므로, 외부에서 setter로 입력 받는다.
- 로거가 잘 작동하는지 확인하는 테스트용 컨트롤러다.
- 여기서 HttpServletRequest를 통해서 요청 URL을 받았다.
  - requestURL 값 `http://localhost:8080/log-demo`
- 이렇게 받은 requestURL 값을 myLogger에 저장해둔다. myLogger는 HTTP 요청 당 각각 구분되므로 다른 HTTP요청 때문에 값이 섞이는 걱정은 하지 않아도 된다.
- *참고*
  - requestURL을 MyLogger에 저장하는 부분은 컨트롤러 보다는 공통 처리가 가능한 스프링 인터셉터나 서블릿 필터 같은 곳을 활용하는 것이 좋다. 여기서는 예제를 단순화하고, 아직 스프링 인터셉터를 학습하지 않은 분들을 위해서 컨트롤러를 사용했다. 스프링 웹에 익숙하다면 인터셉터를 사용해서 구현해보자.
- 비즈니스 로직이 있는 서비스 계층에서도 로그를 출력해보자.
- 여기서 중요한 점이 있다. request scope를 사용하지 않고 파라미터로 이 모든 정보를 서비스 계층에 넘긴다면, 파라미터가 많아서 지저분해진다. 더 문제는 requestURL과 같은 웹과 관련된 정보가 웹과 관련없는 서비스 계층까지 넘어가게 된다. 웹과 관련된 부분은 컨트롤러까지만 사용해야 한다. 서비스 계층은 웹 기술에 종속되지 않고, 가급적 순수하게 유지하는 것이 유지보수 관점에서 좋다.
- request scope의 MyLogger 덕분에 이런 부분을 파라미터로 넘기지 않고, MyLogger의 멤버변수에 저장해서 코드와 계층을 깔끔하게 유지할 수 있다.
- *실제는 기대와 다르게 애플리케이션 실행 시점에 오류 발생*
  - 스프링 애플리케이션을 실행시키면 오류가 발생한다. 메시지 마지막에 싱글톤이라는 단어가 나오고...  스프링 애플리케이션을 실행하는 시점에 싱글톤 빈은 생성해서 주입이 가능하지만, request 스코프 빈은 아직 생성되지 않는다. 이 빈은 실제 고객의 요청이 와야 생성할 수 있다!

### 스코프와 Provider
첫 번째 해결방안은 앞서 배운 Provider를 사용하는 것이다.
간단히 ObjectProvider를 사용해보자
- `ObjectProvider` 덕분에 `ObjectProvider.getObject()`를 호출하는 시점까지 request scope *빈의 생성을 지연* 할 수 있다.
- `ObjectProvider.getObject()`를 호출하는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.
- `ObjectProvider.getObject()`를 `LogDemoController`, `LogDemoService`에서 각각 한번씩 따로 호출해도 같은 HTTP 요청이면 같은 스프링 빈이 반환된다! -> 내가 직접 이걸 구분하려면 얼마나 힘들까 ㅠㅠ...

### 스코프와 Proxy
이번에는 프록시 방식을 사용해보자.
- 여기가 핵심이다. `proxyMode = ScopedProxyMode.TARGET_CLASS`를 추가해주자.
  - 적용 대상이 인터페이스가 아닌 클래스면 `TARGET_CLASS`를 선택
  - 적용 대상이 인터페이스면 `INTERFACES`를 선택
- 이렇게 하면 MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.

*웹 스코프와 프록시 동작 원리*
- *CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.*
  - `@Scope`의 `proxyMode = ScopedProxyMode.TARGET_CLASS`를 설정하면 스프링 컨테이너는 CGLIB라는 바이트 코트를 조작하는 라이브러리를 사용해서, MyLogger를 상속받은 가짜 프록시 객체를 생성한다.
  - 결과를 확인해보면 우리가 등록한 순수한 MyLogger 클래스가 아니라 `MyLogger$$EnhancerBySpringCGLIB`이라는 클래스로 만들어진 객체가 대신 등록된 것을 확인할 수 있다.
  - 그리고 스프링 컨테이너에 "myLogger"라는 이름으로 진짜 대신에 이 가짜 프록시 객체를 등록한다.
  - `ac.getBean("myLogger", MyLogger.class)`로 조회해도 프록시 객체가 조회되는 것을 확인할 수 있다.
  - 그래서 의존관계 주입도 이 가짜 프록시 객체가 주입된다.
- *가짜 프록시 객체는 요청이 오면 그때 내부에서 진짜 빈을 요청하는 위임 로직이 들어있다.*
  - 가짜 프록시 객체는 내부에 진짜 myLogger를 찾는 방법을 알고 있다.
  - 클라이언트가 `myLogger.logic()`을 호출하면 사실은 가짜 프록시 객체의 메서드를 호출한 것이다.
  - 가짜 프록시 객체는 request 스코프의 진짜 `myLogger.logic()`를 호출한다.
  - 가짜 프록시 객체는 원본 클래스를 상속 받아서 만들어졌기 때문에 이 객체를 사용하는 클라이언트 입장에서는 사실 원본인지 아닌지도 모르게, 동일하게 사용할 수 있다.(다형성)
- *동작 정리*
  - CGLIB라는 라이브러리로 내 클래스를 상속 받은 가짜 프록시 객체를 만들어서 주입한다.
  - 이 가짜 프록시 객체는 실제 요청이 오면 그때 내부에서 실제 빈을 요청하는 위임 로직이 들어있다.
  - 가짜 프록시 객체는 실제 request scope와는 관계가 없다. 그냥 가짜이고, 내부에 단순한 위임 로직만 있고, 싱글톤처럼 동작한다.
- *특징 정리*
  - 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있다.
  - 사실 Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 *지연처리* 한다는 점이다.
  - 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.
  - 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
- *주의점*
  - 마치 싱글톤을 사용하는 것 같지만 다르게 동작하기 때문에 결국 주의해서 사용해야 한다.
  - 이런 특별한 scope는 꼭 필요한 곳에만 최소화해서 사용하자. 무분별하게 사용하면 유지보수하기 어려워진다.

---
# Spring MVC
# 💱 웹 애플리케이션 이해
### 모든 것이 HTTP
HTTP 메시지에 모든 것을 전송
- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML (API)
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용
- *지금은 HTTP 시대!*

### 웹 서버(Web Server)
- HTTP 기반으로 동작
- 정적 리소스 제공, 기타 부가기능
- 정적(파일) HTML, CSS, JS, 이미지, 영상
- 예) NGINX, APACHE

![WEB_SERVER](https://github.com/keunoh/spring-mvc/assets/96904103/9c90c04c-0c25-4841-95b3-66c1ec12624e)


### 웹 애플리케이션 서버(WAS - Web Application Server)
- HTTP 기반으로 동작
- 웹 서버 기능 포함 + (정적 리소스 제공 가능)
- 프로그램 코드를 실행해서 애플리케이션 로직 수행
    - 동적 HTML, HTTP API(JSON)
    - 서블릿, JSP, 스프링 MVC
- 예) 톰캣(Tomcat) Jetty, Undertow

![WAS](https://github.com/keunoh/spring-mvc/assets/96904103/13dd68f3-46ed-47d7-a304-194755e2ea70)

### 웹 서버, 웹 애플리케이션 서버(WAS) 차이
- 웹 서버는 정적 리소스(파일), WAS는 애플리케이션 로직
- 사실은 둘의 용어도 경계도 모호함
    - 웹 서버도 프로그램을 실행하는 기능을 포함하기도 함
    - 웹 애플리케이션 서버도 웹 서버의 기능을 제공함
- 자바는 서블릿 컨테이너 기능을 제공하면 WAS
    - 서블릿 없이 자바코드를 실행하는 서버 프레임워크도 있음
- WAS는 애플리케이션 코드를 실행하는데 더 특화

### 웹 시스템 구성 - WAS, DB
- WAS, DB 만으로 시스템 구성 가능
- WAS는 정적 리소스, 애플리케이션 로직 모두 제공 가능
- WAS가 너무 많은 역할을 담당, 서버 과부하 우려
- 가장 비싼 애플리케이션 로직이 정적 리소스 때문에 수행이 어려울 수 있음
- WAS 장애시 오류 화면도 노출 불가능

![WAS_DB](https://github.com/keunoh/spring-mvc/assets/96904103/6d3e6d1b-33a4-44c1-a49d-70cc55b6868b)

### 웹 시스템 구성 - WEB, WAS, DB
- 정적 리소스는 웹 서버가 처리
- 웹 서버는 애플리케이션 로직같은 동적인 처리가 필요하면 WAS에 요청을 위임
- WAS는 중요한 애플리케이션 로직 처리 전담
- 효율적인 리소스 관리
    - 정적 리소스가 많이 사용되면 Web 서버 증설
    - 애플리케이션 리소스가 많이 사용되면 WAS 증설
- 정적 리소스만 제공하는 웹 서버는 잘 죽지 않음
- 애플리케이션 로직이 동작하는 WAS 서버는 잘 죽음
- WAS, DB 장애시 WEB 서버가 오류 화면 제공 가능

![WEB_WAS_DB](https://github.com/keunoh/spring-mvc/assets/96904103/b704fd95-7fef-4c75-8506-ce09b24a6840)

### 서블릿
- 특징
    - ulrPatterns(/hello)의 URL이 호출되면 서블릿 코드가 실행
    - HTTP 요청 정보를 편리하게 사용할 수 있는 HttpServletRequest
    - HTTP 응답 정보를 편리하게 제공할 수 있는 HttpServletResponse
    - 개발자는 HTTP 스펙을 매우 편리하게 사용

- HTTP 요청, 응답 흐름
    - HTTP 요청 시
        - WAS는 Request, Response 객체를 새로 만들어서 서블릿 객체 호출
        - 개발자는 Request 객체에서 HTTP 요청 정보를 편리하게 꺼내서 사용
        - 개발자는 Response 객체에 HTTP 응답 정보를 편리하게 입력
        - WAS는 Response 객체에 담겨있는 내용으로 HTTP 응답 정보를 생성

![SERVLET](https://github.com/keunoh/spring-mvc/assets/96904103/1f264362-ad9a-4b17-8cf0-a2dff25f7228)

### 서블릿 컨테이너
- 톰캣처럼 서블릿을 지언하는 WAS를 서블릿 컨테이너라고 함
- 서블릿 컨테이너는 서블릿 객체를 생성, 초기화, 호출, 종료하는 생명주기 관리
- 서블릿 객체는 *싱글톤으로 관리*
    - 고객의 요청이 올 때 마다 계속 객체를 생성하는 것은 비효율
    - 최초 로딩 시점에 서블릿 객체를 미리 만들어두고 재활용
    - 모든 고객 요청은 동일한 서블릿 객체 인스턴스에 접근
    - *공유 변수 사용 주의*
    - 서블릿 컨테이너 종료시 함께 종료
- JSP도 서블릿으로 변환 되어서 사용
- 동시 요청을 위한 멀티 쓰레드 처리 지원

# 👨‍👩‍👧‍👧 동시 요청 - 멀티 쓰레드
### 쓰레드
- 애플리케이션 코드를 하나하나 순차적으로 실행하는 것은 쓰레드
- 자바 메인 메서드를 처음 실행하면 main이라는 이름의 쓰레드가 실행
- 쓰레드가 없다면 자바 애플리케이션 실행이 불가능
- 쓰레드는 한번에 하나의 코드 라인만 수행
- 동시 처리가 필요하면 쓰레드를 추가로 생성

### 요청 마다 쓰레드 생성 [ 장단점 ]
- 장점
    - 동시 요청을 처리할 수 있다.
    - 리소스(CPU, 메모리)가 허용할 때까지 처리 가능
    - 하나의 쓰레드가 지연 되어도, 나머지 쓰레드는 정상 동작한다.
- 단점
    - 쓰레드는 생성 비용이 매우 비싸다.
        - 고객의 요청이 올 때마다 쓰레드를 생성하면, 응답 속도가 늦어진다.
    - 쓰레드는 컨텍스트 스위칭 비용이 발생한다.
    - 쓰레드 생성에 제한이 없다.
        - 고객 요청이 너무 많이 오면, CPU, 메모리 임게점을 넘어서 서버가 죽을 수 있다.

### 쓰레드 풀
요청마다 쓰레드 생성의 단점 보완
- 특징
    - 필요한 쓰레드를 쓰레드 풀에 보관하고 관리한다.
    - 쓰레드 풀에 생성 가능한 쓰레드의 최대치를 관리한다. 톰캣은 최대 200개 기본 설정 (변경 가능)
- 사용
    - 쓰레드가 필요하면, 이미 생성되어 있는 쓰레드를 쓰레드 풀에서 꺼내서 사용한다.
    - 사용을 종료하면 쓰레드 풀에 해당 쓰레드를 반납한다.
    - 최대 쓰레드가 모두 사용중이어서 쓰레드 풀에 쓰레드가 없으면?
        - 기다리는 요청은 거절하거나 특정 숫자만큼만 대기하도록 설정할 수 있다.
- 장점
    - 쓰레드가 미리 생성되어 있으므로, 쓰레드를 생성하고 종료하는 비용(CPU)이 절약되고, 응답 시간이 빠르다.
    - 생성 가능한 쓰레드의 최대치가 있으므로 너무 많은 요청이 들어와도 기존 요청은 안전하게 처리할 수 있다.

![THREAD_POOL](https://github.com/keunoh/spring-mvc/assets/96904103/5e113396-7edb-47f2-ba80-07e7cb47b8f0)

### 실무 팁
- WAS의 주요 튜닝 포인트는 최대 쓰레드(max thread) 수 이다.
- 이 값을 너무 낮게 설정하면?
    - 동시 요청이 많으면, 서버 리소스는 여유롭지만, 클라이언트는 금방 응답 지연
- 이 값을 너무 높게 설정하면?
    - 동시 요청이 많으면, CPU, 메모리 리소스 임계점 초과로 서버 다운
- 장애 발생시?
    - 클라우드면 일단 서버부터 늘리고, 이후에 튜닝
    - 클라우드가 아니면 열심히 튜닝

### 쓰레드 풀의 적정 숫자
- 적정 숫자는 어떻게 찾나요?
- 애플리케이션 로직의 복잡도, CPU, 메모리, IO 리소스 상황에 따라 모두 다름
- 성능 테스트
    - 최대한 실제 서비스와 유사하게 성능 테스트 시도
    - 툴: 아파치 ab, 제이미터, nGrinder

### WAS의 멀티 쓰레드 지원 [ 핵심 ]
- 멀티 쓰레드에 대한 부분은 WAS가 처리
- `개발자가 멀티 쓰레드 관련 코드를 신경쓰지 않아도 됨`
- 개발자는 마치 `싱글 쓰레드 프로그래밍을 하듯이 편리하게 소스 코드를 개발`
- 멀티 쓰레드 환경이므로 싱글톤 객체(서블릿, 스프링 빈)는 주의해서 사용

# 📊 HTML, HTTP API, CSR, SSR
### 정적 리소스
- 고정된 HTML 파일, CSS, JS, 이미지, 영상 등을 제공
- 주로 웹 브라우저

### HTML 페이지
- 동적으로 필요한 HTML 파일을 생성해서 전달
- 웹 브라우저 : HTML 해석

### HTTP API
- HTML이 아니라 데이터를 전달
- 주로 JSON 형식 사용
- 다양한 시스템에서 호출
- 데이터만 주고 받음, UI 화면이 필요하면, 클라이언트가 별도 처리
- 앱, 웹 클라이언트, 서버 to 서버
    - UI 클라이언트 점점
        - 앱 클라이언트(아이폰, 안드로이드, PC 앱)
        - 웹 브라우저에서 자바스크립트를 통한 HTTP API 호출
        - React, Vue.js 같은 웹 클라이언트
    - 서버 to 서버
        - 주문 서버 -> 결제 서버
        - 기업간 데이터 통신

### 서버사이드 렌더링, 클라이언트 사이드 렌더링
- SSR - 서버 사이드 렌더링
    - HTML 최종 결과를 서버에서 만들어서 웹 브라우저에 전달
    - 주로 정적인 화면에 사용
    - 관련 기술 : JSP, 타임리프 -> `백엔드 개발자`
- CSR - 클라이언트 사이드 렌더링
    - HTML 겨로가를 자바스크립트를 사용해 웹 브라우저에서 동적으로 생성해서 적용
    - 주로 동적인 화면에 사용, 웹 환경을 마치 앱 처럼 필요한 부분부분 변경할 수 있음
    - 예) 구글 지도, Gmail, 구글 캘린더
    - 관련기술 : React, Vue.js -> `웹 프론트엔드 개발자`

![SSR](https://github.com/keunoh/spring-mvc/assets/96904103/479f2c06-dd75-4956-9742-be04cef2efc3)
![CSR](https://github.com/keunoh/spring-mvc/assets/96904103/b4974b19-f5f3-4076-b67c-47770b44a993)

### 어디까지 알아요 하나요?
백엔드 개발자 입장에서 UI 기술
- 백엔드 - 서버 사이드 렌더링 기술
    - JSP, 타임리프
    - 화면이 정적이고, 복잡하지 않을 때 사용
    - 백엔드 개발자는 서버 사이드 렌더링 기술 학습 필수
- 웹 프론트 엔드 - 클라이언트 사이드 렌더링 기술
    - React, Vue.js
    - 복잡하고 동적인 UI 사용
    - 웹 프론트엔드 개발자의 전문 분야
- 선택과 집중
    - 백엔드 개발자의 웹 프론트엔드 기술 학습은 옵션
    - 백엔드 개발자는 서버, DB, 인프라 등등 수 많은 백엔드 기술을 공부해야 한다.
    - 웹 프론트엔드도 깊이있게 잘 하려면 숙련에 오랜 시간이 필요하다.

# 📜 자바 백엔드 웹 기술 역사
- 과거 기술
    - 서블릿 - 1997
        - HTML 생성이 어려움
    - JSP - 1999
        - HTML 생성은 편리하지만, 비즈니스 로직까지 너무 많은 역할 담당
    - 서블릿, JSP 조합 MVC 패턴 사용
        - 모델, 뷰 컨트롤러로 역할을 나누어 개발
    - MVC 프레임워크 춘추 전국 시대 - 2000년 초 ~ 2010년 초
        - MVC 패턴 자동화, 복잡한 웹 기술을 편리하게 사용할 수 있는 다양한 기능 지원
        - 스트럿츠, 웹워크, 스프링 MVC(과거버전)
- 현재 사용 기술
    - `애노테이션 기반의 스프링 MVC 등장`
        - @Controller
        - MVC 프레임워크의 춘추 전국 시대 마무리
    - `스프링 부트의 등장`
        - 스프링 부트는 서버를 내장
        - 과거에는 서버에 WAS를 직접 설치하고, 소스는 War 파일을 만들어서 설치한 WAS에 배포
        - 스프링 부트는 빌드 결과(Jar)에 WAS 서버 포함 -> 빌드 배포 단순화
- 최신 기술 - 스프링 웹 기술의 분화
    - Web Servlet - Spring MVC
    - Web Reactive - Spring WebFlux
        - 특징
            - 비동기 넌 블러킹 처리
            - 최소 쓰레드로 최대 성능 - 쓰레드 컨텍스트 스위칭 비용 효율화
            - 함수형 스타일로 개발 - 동시처리 코드 효율화
            - 서블릿 기술 사용X
        - `그런데`
            - 웹 플럭스는 기술적 난이도 매우 높음
            - 아직은 RDB 지원 부족
            - 일반 MVC의 쓰레드 모델도 충분히 빠르다.
            - 실무에서 아직 많이 사용하지는 않음(전체 1% 이하)
- 자바 뷰 템플릿 역사 [ HTML을 편리하게 생성하는 뷰 기능 ]
    - JSP
        - 속도 느림, 기능부족
    - 프리마커(Freemarker), Velocity(벨로시티)
        - 속도 문제 해결, 다양한 기능
    - 타임리프(Thymeleaf)
        - 내추럴 템플릿 : HTML의 모양을 유지하면서 뷰 템플릿 적용 가능
        - 스프링 MVC와 강력한 기능 통합
        - `최선의 선택`, 단 성능은 프리마커, 벨로시티가 더 빠름

# 🎫 서블릿
### HttpServletRequest - 개요
HTTP 요청 메시지를 개발자가 직접 파싱해서 사용해도 되지만, 매우 불편할 것이다.
서블릿은 개발자가 HTTP 요청 메시지를 편리하게 사용할 수 있도록 개발자 대신에 HTTP 요청 메시지를 파싱한다.
그리고 그 결과를 `HttpServletRequest` 객체에 담아서 제공한다.
- *중요*
    - HttpServletRequest, HttpServletResponse를 사용할 떄 가장 중요한 점은 이 객체들이 HTTP 요청 메시지, HTTP 응답 메시지를 편리하게 사용하도록 도와주는 객체라는 점이다. 따라서 이 기능에 대해서 깊이 있는 이해를 하려면 "HTTP 스펙이 제공하는 요청, 응답 메시지 자체를 이해"해야 한다.

### HTTP 요청 데이터 - 개요
HTTP 요청 메시지를 통해 클라이언트에서 서버로 데이터를 전달하는 방법을 알아보자.
- 주로 다음 3가지 방법을 사용한다.
    - `GET - 쿼리 파라미터`
        - /url?username=hello&age=20
        - 메시지 바디 없이, URL의 쿼리 파라미터에 데이터를 포함해서 전달
        - 예) 검색, 필터, 페이징등에서 많이 사용하는 방식
    - `POST - HTML Form`
        - content-type: application/x-www-form-urlencoded
        - 메시지 바디에 쿼리 파라미터 형식으로 전달 username=hello&age=20
        - 예) 회원 가입, 상품 주문, HTML Form 사용
    - `HTTP message body`에 데이터를 직접 담아서 요청
        - HTTP API에서 주로 사용, JSON, XML, TEXT
        - content-type: application/json
        - 데이터 형식은 주로 JSON 사용
            - POST, PUT, PATCH
- *참고*
    - content-type은 HTTP 메시지 바디의 데이터 형식을 지정한다. `GET URL 쿼리 파라미터 형식`으로 클라이언트에서 서버로 데이터를 전달할 때는 HTTP 메시지 바디를 사용하지 않기 때문에 content-type이 없다. `POST HTML Form 형식`으로 데이터를 전달하면 HTTP 메시지 바디에 해당 데이터를 포함해서 보내기 때문에 바디에 포함된 데이터가 어떤 형식인지 content-type을 꼭 지정해야 한다. 이렇게 폼으로 데이터를 전송하는 형식을 application/x-www-form-urlencoded라 한다.
    - inputStream은 byte코드를 반환한다. byte 코드는 우리가 읽을 수 있는 문자(String)로 보려면 문자표(Charset)를 지정해주어야 한다. 여기서는 UTF_8 Charset을 지정해주었다.
    - JSON 결과를 파싱해서 사용할 수 있는 자바 객체로 변환하려면 Jackson, Gson 같은 JSON 변환 라이브러리를 추가해서 사용해야 한다. 스프링 부트로 Spring MVC를 선택하면 기본으로 Jackson 라이브러리(ObjectMapper)를 함꼐 제공한다.
    - HTML form 데이터도 메시지 바디를 통해 전송되므로 직접 읽을 수 있다. 하지만 편리한 파라미터 조회기능(request.getParameter(...))을 이미 제공하기 때문에 파라미터 조회 기능을 사용하면 된다.

### HttpServletResponse - 기본 사용법
- 역할
    - HTTP 응답 메시지 생성
        - HTTP 응답코드 지정
        - 헤더 생성
        - 바디 생성

### HTTP 응답 데이터 - 단순 텍스트, HTML, JSON
HTTP 응답 메시지는 주로 다음 내용을 담아서 전달한다.
- 단순 텍스트 응답
    - 앞에서 살펴봄 (writer.println("ok);)
    - HTML 응답
    - HTTP API - MessageBody JSON 응답
- JSON 응답
    - HTTP 응답으로 JSON을 반환할 때는 content-type을 application/json로 지정해야 한다. Jackson 라이브러리가 제공하는 objectmapper.writeAsString()을 사용하면 객체를 JSON문자로 변경할 수 있다.

- *참고*
    - application/json은 스펙상 utf-8 형식을 사용하도록 정의되어 있다. 그래서 스펙에서 chaset=utf-8과 같은 추가 파라미터를 지원하지 않는다. 따라서 application/json 이라고만 사용해야지 application/json;charset=utf-8이라고 전달하는 것은 의미 없는 파라미터를 추가한 것이 된다. response.getWriter()를 사용하면 추가 파라미터를 자동으로 추가해버린다. 이때는 response.getOuputStream()으로 출력하면 그런 문제가 없다.

# 🎳 서블릿, JSP, MVC 패턴
### 템플릿 엔진으로
지금까지 서블릿과 자바 코드만으로 HTML을 만들어 보았다.
서블릿 덕분에 동적으로 원하는 HTML을 마음껏 만들 수 있다.
정적인 HTML 문서라면 화면이 계속 달라지는 회원의 저장 결과라던가, 회원 목록 같은 동적인 HTML을 만드는 일은 불가능할 것이다.
그런데, 코드에서 보듯이 이것은 매우 복잡하고 비효율적이다.
자바 코드로 HTML을 만들어 내는 것보다 차라리 HTML 문서에 동적으로 변경해야 하는 부분만 자바 코드를 넣을 수 있다면 더 편리할 것이다.
이것이 바로 템플릿 엔진이 나온 이유이다.
템플릿 엔진을 사용하면 HTML 문서에서 필요한 곳만 코드를 적용해서 동적으로 변경할 수 있다.
템플릿 엔진에는 JSP, Thymeleaf, Freemarker, Velocity 등이 있다.

### 서블릿과 JSP의 한계
서블릿으로 개발할 때는 뷰(View)화면을 위한 HTML을 만드는 작업이 자바 코드에 섞여서 지저분하고 복잡했다.
JSP를 사용한 덕분에 뷰를 생성하는 HTML 작업을 깔끔하게 가져가고, 중간중간 동적으로 변경이 필요한 부분에만 자바 코드를 적용했다.
그런데 이렇게 해도 해결되지 않는 몇 가지 고민이 남는다.

회원 저장 JSP를 보자. 코드의 상위 절반은 회원을 저장하기 위한 비즈니스 로직이고, 나머지 하위 절반만 결과를 HTML로 보여주기 위한 뷰 영역이다. 회원 몬록의 경우에도 마찬가지다.
코드를 잘 보면, JAVA 코드, 데이터를 조회하는 리포지토리 등등 다양한 코드가 모두 JSP에 노출되어있다.
JSP가 너무 많은 역할을 한다. 이렇게 작은 프로젝트도 벌써 머리가 아파오는데, 수백 수천줄이 넘어가는 JSP를 떠올려보면 정말 지옥과 같을 것이다.

`MVC 패턴의 등장`   
비즈니스 로직은 서블릿처럼 다른 곳에서 처리하고, JSP는 목적에 맞게 HTML로 화면(View)을 그리는 일에 집중하도록 하자.
과거 개발자들도 모두 비슷한 고민이 있었고, 그래서 MVC 패턴이 등장했다.
우리도 직접 MVC 패턴을 적용해서 프로제그를 리팩토링 해보자.

### MVC 패턴 - 개요
`너무 많은 역할`    
하나의 서블릿이나 JSP만으로 비즈니스 로직과 뷰 렌더링까지 모두 처리하게 되면, 너무 많은 역할을 하게되고, 결과적으로 유지보수가 어려워진다.
비즈니스 로직을 호출하는 부분에 변경이 발생해도 해당 코드를 손대야 하고, UI를 변경할 일이 있어도 비즈니스 로직이 함께 있는 해당 파일을 수정해야 한다.
HTML 코드 하나 수정해야 하는데, 수백줄의 자바 코드가 함께 있다고 상상해보라!
또는 비즈니스 로직을 하나 수정해야 하는데 수백 수천줄의 HTML 코드가 함꼐 있다고 상상해보라.

`변경의 라이프 사이클`  
사실 이게 정말 중요한데, 진짜 문제는 둘 사이에 변경의 라이프 사이클이 다르다는 점이다.
예를 들어서 UI를 일부 수정하는 일과 비즈니스 로직을 수정하는 일은 각각 다르게 발생할 가능성이 매우 높고 대부분 서로에게 영향을 주지 않는다.
이렇게 변경의 라이프 사이클이 다른 부분을 하나의 코드로 관리하는 것은 유지보수하기 좋지 않다.
(물론 UI가 많이 변하면 함께 변경될 가능성도 있다.)

`기능 특화`   
특히 JSP 같은 뷰 템플릿은 화면을 렌더링하는데 최적화 되어 있기 때문에 이 부분의 업무만 담당하는 것이 가장 효과적이다.

`Model View Controller`   
MVC 패턴은 지금까지 학습한 것처럼 하나의 서블릿이나, JSP로 처리하던 것을 컨트롤러(Controller)와 뷰(View)라는 영역으로 서로 역할을 나눈 것을 말한다.
웹 애플리케이션은 보통 이 MVC 패턴을 사용한다.
- 컨트롤러 : HTTP 요청을 받아서 파라미터를 검증하고, 비즈니스 로직을 실행한다. 그리고 뷰에 전달할 결과 데이터를 조회해서 모델에 담는다.
- 모델 : 뷰에 출력할 데이터를 담아둔다. 뷰가 필요한 데이터를 모두 모델에 담아서 전달해주는 덕분에 뷰는 비즈니스 로직이나 데이터 접근을 몰라도 되고, 화면을 렌더링하는 일에 집중할 수 있다.
- 뷰 : 모델에 담겨있는 데이터를 사용해서 화면을 그리는 일에 집중한다. 여기서는 HTML을 생성하는 부분을 말한다.

`참고`   
컨트롤러에 비즈니스 로직을 둘 수도 있지만, 이렇게 되면 컨트롤러가 너무 많은 역할을 담당한다.
그래서 일반적으로 비즈니스 로직은 서비스(Service)라는 계층을 별도로 만들어서 처리한다.
그리고 컨트롤러는 비즈니스 로직이 있는 서비스를 호출하는 역할을 담당한다.
참고로 비즈니스 로직을 변경하면 비즈니스 로직을 호출하는 컨트롤러의 코드도 변경될 수 있다.
앞에서는 이해를 돕기 위해 비즈니스 로직을 호출한다는 표현보다는, 비즈니스 로직이라 설명했다.
![MVC2](https://github.com/keunoh/spring-mvc/assets/96904103/c5c7f7c7-3ccc-45fe-b973-338eb7a809c8)

### MVC 패턴 - 적용
서블릿은 컨트롤러로 사용하고, JSP를 뷰로 사용해서 MVC 패턴을 적용해보자.
Model은 HttpServletRequest 개게를 사용한다. request는 내부에 데이터 저장소를 가지고 있는데,
request.setAttribute(), request.getAttribute()를 사용하면 데이터를 보관하고, 조회할 수 있다.

*/WEB-INF*   
이 경로안에 JSP가 있으면 외부에서 직접 JSP를 호출할 수 없다. 우리가 기대하는 것은 항상 컨트롤러를 통해서 JSP를 호출하는 것이다.

`redirect vs forward`   
리다이렉트는 실제 클라이언트(웹 브라우저)에 응답이 나갔다, 클라이언트가 redirect 경로로 다시 요청한다.
따라서 클라이언트가 인지할 수 있고, URL 경로도 실제로 변경된다.
반면에 포워드는 서버 내부에서 일어나는 호출이기 때문에 클라이언트가 전혀 인지하지 못 한다.

### MVC 패턴 - 한계
MVC 패턴을 적용한 덕분에 컨트롤러의 역할과 뷰를 렌더링하는 역할을 명확하게 구분할 수 있다.
특히 뷰는 화면을 그리는 역할에 충실한 덕분에, 코드가 깔끔하고 직관적이다.
단순하게 모델에서 필요한 데이터를 꺼내고, 화면을 만들면 된다.
그런데 컨트롤러는 딱 봐도 중복이 많고, 필요하지 않은 코드들도 많이 보인다.

- MVC 컨트롤러의 단점
    - 포워드 중복
        - View로 이동하는 코드가 항상 중복 호출되어야 한다. 물론 이 부분을 메서드로 공통화해도 되지만, 해당 메서드도 항상 직접 호출해야 한다.
    - ViewPath 중복
        - prefix: `/WEB-INF/views/`
        - suffix: `.jsp`
            - 그리고 만약 jsp가 아닌 thymeleaf 같은 다른 뷰로 변경한다면 전체 코드를 다 변경해야 한다.
    - 사용하지 않는 코드
        - 다음 코드를 사용할 때도 있고, 사용하지 않을 때도 있다. 특히 response는 현재 코드에서 사용되지 않는다.
        - HttpServletRequest request, HttpServletResponse response
        - 그리고 이런 HttpServletRequest, HttpServletResponse를 사용하는 코드는 테스트 케이스를 작성하기도 어렵다.
    - 공통 처리가 어렵다.
        - 기능이 복잡해 질수록 컨트롤러에서 공통으로 처리해야 하는 부분이 점점 더 많이 증가할 것이다. 단순히 공통 기능을 메서드로 뽑으면 될 것 같지만, 결과적으로 해당 메서드를 항상 호출해야 하고, 실수로 호출하지 않으면 문제가 될 것이다. 그리고 호출하는 것 자체도 중복이다.
    - 정리하면 공통 처리가 어렵다는 문제가 있다.
        - 이 문제를 해결하려면 컨트롤러 호출 전에 먼저 공통 기능을 처리해야 한다. 소위 `수문장 역할`을 하는 기능이 필요하다. `프론트 컨트롤러(Front Controller) 패턴`을 도입하면 이런 문제를 깔끔하게 해결할 수 있다. (입구를 하나로!) 스프링 MVC의 핵심도 바로 이 프론트 컨트롤러에 있다.

# 🎼 MVC 프레임워크 만들기
### 프론트 컨트롤러 패턴 소개
![FRONT_CONTROLLER](https://github.com/keunoh/spring-mvc/assets/96904103/caf71c7e-7274-43a5-ab8f-acfe2a5b2fab)

- *FrontController 패턴 특징*
    - 프론트 컨트롤러 서블릿 하나로 클라이언트의 요청을 받음
    - 프론트 컨트롤러가 요청에 맞는 컨트롤러를 찾아서 호출
    - 입구를 하나로!
    - 공통 처리 기능
    - 프론트 컨트롤러를 제외한 나머지 컨트롤러는 서블릿을 사용하지 않아도 됨
- *스프링 웹 MVC와 프론트 컨트롤러*
    - 스프링 웹 MVC의 핵심도 바로 `FrontController`
    - 스프링 웹 MVC의 `DispatcherServlet`이 FrontController 패턴으로 구현되어 있음

### 프론트 컨트롤러 도입 - v1
프론트 컨트롤러를 단계적으로 도입해보자.
이번 목표는 기존 코드를 최대한 유지하면서, 프론트 컨트롤러를 도입하는 것이다.
먼저 구조를 맞추어두고 점진적으로 리팩토링 해보자.

*V1 구조*  
![FRONT_CONTROLLER_V1](https://github.com/keunoh/spring-mvc/assets/96904103/df5aa14f-2c12-4f79-828a-c709d9ec9779)

서블릿과 비슷한 모양의 컨트롤러 인터페이스를 도입한다.
각 컨트롤러들은 이 인터페이스를 구현하면 된다.
프론트 컨트롤러는 이 인터페이스를 호출해서 구현과 관계없이 로직의 일관성을 가져갈 수 있다.
이제 이 인터페이스를 구현한 컨트롤러를 만들어 보자.
지금 단계에서는 기존 로직을 최대한 유지하는게 핵심이다.

#### ⭐ TIP - 개발하다보면 아키텍처를 개선해야 될 일들이 생긴다. 구조적인 큰 거를 개선할 때랑 디테일한 부분을 개선할 때랑 준위가 다르다.  구조를 개선할 때는 일단 구조적인 것만 개선하고 기존 코드는 최대한 유지시켜야 한다. 그 다음에 구조를 바꿨는데 문제가 없으면 이제 세세한 부분들을 개선하는 식으로 해야한다. 구조적인 것 개선하고 커밋하고 배포해서 잘 됐는지 확인하고 완전히 끝낸다. 그 다음 단계로 세밀한 것을 개선한다.

### View 분리 - v2
모든 컨트롤러에서 뷰로 이동하는 부분에 중복이 있고, 깔끔하지 않다.
이 부분을 깔끔하게 분리하기 위해 별도로 뷰를 처리하는 객체를 만들자.

*V2 구조*  
![FRONT_CONTROLLER_V2](https://github.com/keunoh/spring-mvc/assets/96904103/ae809172-b0f9-4f0d-8a08-65f6b1823a4d)

### Model 추가 - v3
*서블릿 종속성 제거*  
컨트롤러 입장에서 HttpServletRequest, HttpServletResponse가 꼭 필요할까?
요청 파라미터 정보는 자바의 Map으로 대신 넘기도록 하면 지금 구조에서는 컨트롤러가 서블릿 기술을 몰라도 동작할 수 있다.
그리고 request 객체를 Model로 사용하는 대신에 별도의 Model 객체를 만들어서 반환하면 된다.
우리가 구현하는 컨트롤러가 서블릿 기술을 전혀 사용하지 않도록 변경해 보자.
이렇게 하면 구현코드도 매우 단순해지고, 테스트 코드 작성도 쉽다.

*뷰 이름 중복 제거*  
컨트롤러에서 지정하는 뷰 이름에 중복이 있는 것을 확인할 수 있다.
컨트롤러는 `뷰의 논리 이름`을 반환하고, 실제 물리 위치의 이름은 프론트 컨트롤러에서 처리하도록 단순화하자.
이렇게 해두면 향후 뷰의 폴더 위치가 함께 이동해도 프론트 컨트롤러만 고치면 된다.

![FRONT_CONTROLLER_V3](https://github.com/keunoh/spring-mvc/assets/96904103/31e7c77e-ddac-4a18-8f95-651311da5d6c)

*ModelView*  
지금까지 컨트롤러에서 서블릿에 종속적인 HttpServletRequest를 사용했다.
그리고 Model도 request.setAttribute()를 통해 데이터를 저장하고 뷰에 전달했다.
서블릿의 종속성을 제거하기 위해 Model을 직접 만들고, 추가로 View 이름까지 전달하는 객체를 만들어보자.
(이번 버전에서는 컨트롤러에서 HttpServletRequest를 사용할 수 없다. 따라서 직접 request.setAttribute()를 호출할 수도 없다. Model이 별도로 필요하다.)

*뷰 리졸버*  
컨트롤러가 반환한 논리 뷰 이름을 실제 물리 뷰 경로로 변경한다. 그리고 실제 물리 경로가 있는 MyView객체를 반환한다.

### 단순하고 실용적인 컨트롤러 - v4
앞서 만든 v3 컨트롤러는 서블릿 종속성을 제거하고 뷰 경로의 중복을 제거하는 등, 잘 설계된 컨트롤러이다.
그런데 실제 컨트롤러 인터페이스를 구현하는 개발자 입장에서 보면, 항상 ModelView 객체를 생성하고 반환해야 하는 부분이 조금은 번거롭다.
좋은 프레임워크는 아키텍처도 중요하지만, 그와 더불어 실제 개발하는 개발자가 단순하고 편리하게 사용할 수 있어야 한다.
소위 실용성이 었어야 한다. 이번에는 v3를 조금 변경해서 실제 구현하는 개발자들이 매우 편리하게 개발할 수 있는 v4 버전을 개발해보자.

![FRONT_CONTROLLER_V4](https://github.com/keunoh/spring-mvc/assets/96904103/8c304037-a4bf-48bf-bc7a-3f19378d6f83)
- 기본적인 구조는 v3와 같다. 대신에 컨트롤러가 ModelView를 반환하지 않고, ViewName만 반환한다. 이번 버전은 인터페이스에 ModelView가 없다. model 객체는 파라미터로 전달되기 때문에 그냥 사용하면 되고, 결과로 뷰의 이름만 반환해주면 된다.

*정리*  
이번 버전의 컨트롤러는 매우 단순하고 실용적이다.
기존 구조에서 모델을 파라미터로 넘기고, 뷰의 논리 이름을 반환한다는 작은 아이디어를 적용했을 뿐인데,
컨트롤러를 구현하는 개발자 입장에서 보면 이제 군더더기 없는 코드를 작성할 수 있다.
또한 중요한 사실은 여기까지 한번에 온 것이 아니라는 점이다.
프레임워크가 점진적으로 발전하는 과정속에서 이런 방법도 찾을 수 있다.
#### 프레임워크나 공통 기능이 수고로워야 사용하는 개발자가 편리해진다.

### 유연한 컨트롤러1 - v5
만약 어떤 개발자는 ControllerV3 방식으로 개발하고 싶고, 어떤 개발자는 ControllerV4 방식으로 개발하고 싶다면 어떻게 해야할까?

*어댑터 패턴*  
지금까지 우리가 개발한 프론트 컨트롤러는 한 가지 방식의 컨트롤러 인터페이스만 사용할 수 있다.
ControllerV3, ControllerV4는 완전히 다른 인터페이스이다. 따라서 호환이 불가능하다.
마치 v3는 110v이고, v4는 220v 전기 콘센트 같은 것이다. 이럴 때 사용하는 것이 바로 어댑터이다.
어댑터 패턴을 사용해서 프론트 컨트롤러가 다양한 방식의 컨트롤러를 처리할 수 있도록 변경해보자.

![FRONT_CONTROLLER_V5](https://github.com/keunoh/spring-mvc/assets/96904103/32c2d4b0-e174-4cae-b991-7618ec2cec3a)

- 핸들러 어댑터 : 중간에 어댑터 역할을 하는 어댑터가 추가되었는데 이름이 핸들러 어댑터이다. 여기서 어댑터 역할을 해주는 덕분에 다양한 종류의 컨트롤러를 호출할 수 있다.
- 핸들러 : 컨트롤러의 이름을 더 넓은 범위인 핸들러로 변경했다. 그 이유는 이제 어댑터가 있기 때문에 꼭 컨트롤러의 개념뿐만 아니라 어떠한 것이든 해당하는 종류의 어댑터만 있으면 다 처리할 수 있기 때문이다.

### 정리
지금까지 v1 ~ v5로 점진적으로 프레임워크를 발전시켜 왔다. 지금까지 한 작업을 정리해보자.
- v1: 프론트 컨트롤러를 도입
    - 기존 구조를 최대한 유지하면서 프론트 컨트롤러를 도입
- v2: View 분류
    - 단순 반복되는 뷰 로직 분리
- v3: Model 추가
    - 서블릿 종속성 제거
    - 뷰 이름 중복 제거
- v4: 단순하고 실용적인 컨트롤러
    - v3와 거의 비슷
    - 구현 입장에서 ModelView를 직접 생성해서 반환하지 않도록 편리한 인터페이스 제공
- v5: 유연한 컨트롤러
    - 어댑터 도입
    - 어댑터를 추가해서 프레임워크를 유연하고 확장성 있게 설계

# 👨‍🎓 스프링 MVC - 구조 이해
![SPRING_MVC](https://github.com/keunoh/spring-mvc/assets/96904103/74ea617d-e8d3-4016-8c03-a9a1e13349b1)
- 동작 순서
    - 핸들러 조회 : 핸들러 매핑을 통해 요청 URL에 매핑된 핸들러(컨트롤러)를 조회한다.
    - 핸들러 어댑터 조회 : 핸들러를 실행할 수 있는 핸들러 어댑터를 조회한다.
    - 핸들러 어댑터 실행 : 핸들러 어댑터를 실행한다.
    - 핸들러 실행 : 핸들러 어댑터가 실제 핸들러를 실행한다.
    - ModelAndView 반환 : 핸들러 어댑터는 핸들러가 반환하는 정보를 ModelAndView로 변환해서 반환한다.
    - ViewResolver 호출 : 뷰 리졸버를 찾고 실행한다.
        - JSP의 경우 : InternalResourceViewResolver가 자동 등록되고, 사용된다.
    - View 반환 : 뷰 리졸버는 뷰의 논리 이름을 물리 이름으로 바꾸고, 렌더링 역할을 담당하는 뷰 객체를 반환한다.
        - JSP의 경우 InternalResourceView(JstlView)를 반환하는데, 내부에 forward() 로직이 있다.
    - 뷰 렌더링 : 뷸ㄹ 통해서 뷰를 렌더링 한다.
- 인터페이스 살펴보기
    - 스프링 MVC의 큰 강점은 DispatcherServlet 코드의 변경 없이, 원하는 기능을 변경하거나 확장할 수 있다는 점이다. 지금까지 설명한 대부분을 확장 가능할 수 있게 인터페이스로 제공한다.
    - 이 인터페이스들만 구현해서 DispatcherServlet에 등록하면 여러분만의 컨트롤러를 만들 수도 있다.
- 컨트롤러 호출
  - HandlerMapping(핸들러 매핑)
    - 핸들러 매핑에서 이 컨트롤러를 찾을 수 있어야 한다.
    - 예) 스프링 빈의 이름으로 핸들러를 찾을 수 있는 핸들러 매핑이 필요하다.
  - HandlerAdapter(핸들러 어댑터)
    - 핸들러 매핑을 통해서 찾은 핸들러를 실행할 수 있는 핸들러 어댑터가 필요하다.
    - 예) Controller 인터페이스를 실행할 수 있는 핸들러 어댑터를 찾고 실행해야 한다.

### 스프링 MVC - 시작하기
스프링이 제공하는 컨트롤러는 애노테이션 기반으로 동작해서, 매우 유연하고 실용적이다.
과거에는 자바 언어에 애노테이션이 없기도 했고, 스프링도 처음부터 이런 유연한 컨트롤러를 제공한 것은 아니다.

- @Cotroller 
  - 스프링이 자동으로 스프링 빈으로 등록한다. (내부에 @Component 애노테이션이 있어서 컴포넌트 스캔의 대상이 됨)
  - 스프링 MVC에서 애노테이션 기반 컨트롤러로 인식한다.
- @RequestMapping
  - 요청 정보를 매핑한다. 해당 URL이 호출되면 이 메서드가 호출된다. 애노테이션 기반으로 동작하기 때문에, 메서드의 이름은 임의로 지으면 된다.

# 👶 스프링 MVC - 기본 기능

### 로깅 라이브러리
스프링 부트 라이브러리를 사용하면 스프링 부트 로깅 라이브러리(spring-boot-starter-logging)가 함께 포함된다.
스프링 부트 로깅 라이브러리를 기본으로 다음 로깅 라이브러리를 사용한다.
- SLF4J - http://www.slf4j.org
- Logback - http://logback.qos.ch  
로그 라이브러리는 Logback, Log4J, Log4J2 등등 수많은 라이브러리가 있는데, 그것을 통합해서 인터페이스로 제공하는 것이 바로 SLF4J 라이브러리다.
쉽게 이야기해서 SLF4J는 인터페이스이고, 그 구현체로 Logback 같은 로그 라이브러리를 선택하면 된다.
실무에서는 스프링 부트가 기본으로 제공하는 Logback을 대부분 사용한다.
- 로그가 출력되는 포맷 확인
  - 시간, 로그 레벨, 프로세스 ID, 쓰레드 명, 클래스명, 로그 메시지
- 로그 레벨 설정을 변경해서 출력 결과를 보자.
  - LEVEL: TRACE > DEBUG > INFO > WARN > ERROR
  - 개발 서버는 debug 출력
  - 운영 서버는 info 출력
- *올바른 로그 사용법*
  - log.debug("data=" + data)
    - 로그 출력 레벨을 info로 설정해도 해당 코드에 있는 "data=" + data가 실제 실행이 되어 버린다. 결과적으로 문자 더하기 연산이 발생한다.
  - log.debug("data={}", data)
    - 로그 출력 레벨을 info로 설정하면 아무일도 발생하지 않는다. 따라서 앞과 같은 의미없는 연산이 발생하지 않는다.
- 로그 사용시 장점
  - 쓰레드 정보, 클래스 이름 같은 부가 정보를 함께 볼 수 있고, 출력 모양을 조정할 수 있다.
  - 로그 레벨에 따라 개발 서버에서는 모든 로그를 출력하고, 운영서버에서는 출력하지 않는 등, 로그를 상황에 맞게 조절할 수 있다.
  - 시스템 아웃 콘솔에만 출력하는 것이 아니라, 파일이나 네트워크 등, 로그를 별도의 위치에 남길 수 있다. 특히 파일로 남길 때는 일별, 특정 용량에 따라 로그를 분할하는 것도 가능하다.
  - 성능도 일반 System.out보다 좋다. (내부 버퍼링, 멀티 쓰레드 등등) 그래스 실무에서는 꼭 로그를 사용해야 한다.

### HTTP 요청 - 기본, 헤더 조회
애노테이션 기반의 스프링 컨트롤러는 다양한 파라미터를 지원한다.
이번 시간에는 HTTP 헤더 정보를 조회하는 방법을 알아보자.
- HttpServletRequest
- HttpServletResponse
- HttpMethod : HTTP 메서드를 조회한다. org.springframework.http.HttpMethod
- Locale : Locale 정보를 조회한다.
- @RequestHeader MultiValueMap<String, String> headerMap
  - 모든 HTTP 헤더를 MultiValueMap 형식으로 조회한다.
- @RequestHeader("host") String host
  - 특정 HTTP 헤더를 조회한다.
  - 속성
    - 필수 값 여부 : required
    - 기본 값 속성 : defaultValue
- @CookieValue(value = "myCookie", required = false) String cookie
  - 특정 쿠키를 조회한다.
  - 속성
    - 필수 값 여부 : required
    - 기본 값 : defaultValue
- MultiValueMap
  - Map과 유사한데, 하나의 키에 여러 값을 받을 수 있다.
  - HTTP header, HTTP 쿼리 파라미터와 같이 하나의 키에 여러 값을 받을 때 사용한다.
    - keyA=value1&keyA=value2
- 참고
  - @Controller의 사용가능한 파라미터 목록은 다음 공식 메뉴얼에서 확인할 수 있다.
    - https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments
  - @Controller의 사용 가능한 응답 값 목록을 다음 공식 메뉴얼에서 확인할 수 있다.
    - https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types

### HTTP 요청 파라미터 - @RequestParam
- @RequestParam : 파라미터 이름으로 바인딩
  - @RequestParam의 name(value) 속성이 파라미터 이름으로 사용
    - @RequestParam("username") String memberName -> request.getParameter("username")
    - 기본값이 파라미터 필수(true)이다.
  - 파라미터를 Map, MultiValueMap으로 조회할 수 있다.
    - @RequestParam Map 
      - Map(key=value)
    - @RequestParam MultiValueMap
      - MultiValueMap(key=[value1, value2, ...])
  - 주의
    - @RequestParam 애노테이션을 생략하면 스프링 MVC는 내부에서 required=false를 적용한다.
    - 이렇게 애노테이션을 완전히 생략해도 되는데, 너무 없는 것도 약간 과하다는 주관적 생각이 있다. 
    - @RequestParam이 있으면 명확하게 요청 파라미터에서 데이터를 읽는다는 것을 알 수 있다.
    - /request-param?username=
      - 파라미터 이름만 있고 값이 없는 경우 -> 빈문자로 통과
    - 기본형(primitive)에 null 입력
      - @RequestParam(required = false) int age
        - null을 int에 입력하는 것은 불가능(500 예외 발생)
        - 따라서 null을 받을 수 있는 Integer로 변경하거나, 또는 defaultValue 사용
- @ResponseBody : View 조회를 무시하고, HTTP message body에 직접 해당 내용 입력
- @ModelAttribute : 요청 파라미터의 값을 객체에 담아서 전달 받을 수 있다.
  - HelloData 객체를 생성한다.
  - 요청 파라미터의 이름으로 HelloData 객체의 프로퍼티를 찾는다. 그리고 해당 프로퍼티의 setter를 호출해서 파라미터의 값을 입력(바인딩) 한다.
  - 예) 파라미터 이름이 username이면 setUsername() 메서드를 찾아서 호출하면서 값을 입력한다.

### HTTP 요청 메시지 - 단순 텍스트
- HTTP message body에 데이터를 직접 담아서 요청
  - HTTP API에서 주로 사용, JSON, XML, TEXT
  - 데이터 형식은 주로 JSON 사용
  - POST, PUT, PATCH
- 요청 파라미터와 다르게, HTTP 메시지 바디를 통해 데이터가 직접 넘어오는 경우는 @RequestParam, @ModelAttribute를 사용할 수 없다. (물론 HTML Form 형식으로 전달되는 경우는 요청 파라미터로 인정된다.)
- HTTP 메시지 바디의 데이터 읽기
  - HTTP 메시지 바디의 데이터를 InputStream을 사용해서 직접 읽을 수 있다. (방법1)
  - InputStream, OutputStream 이용 (방법2)
    - InputStream(Reader) : HTTP 요청 메시지 바디의 내용을 직접 조회
    - OutputStream(Writer) : HTTP 응답 메시지의 바디에 직접 결과 출력
  - HttpEntity 이용 (방법3)
    - HttpEntity : HTTP header, body 정보를 편리하게 조회
      - 메시지 바디 정보를 직접 조회
      - 요청 파라미터를 조회하는 기능과 관계 없음!!! @RequestParam X, @ModelAttribute X
    - HttpEtntiy는 응답에도 사용가능
      - 메시지 바디 정보 직접 반환
      - 헤더 정보 포함 가능
  - @RequestBody (방법4)
    - @RequestBody를 사용하면 HTTP 메시지 바디 정보를 편리하게 조회할 수 있다.
    - 참고로 헤더 정보가 필요하다면 HttpEntity를 사용하거나 @RequestHeader를 사용하면 된다.
    - 이렇게 메시지 바디를 직접 조회하는 기능은 요청 파라미터를 조회하는 @RequestParam, @ModelAttribute와는 전혀 관계가 없다!!!
- 요청 파라미터 vs HTTP 메시지 바디
  - 요청 파라미터를 조회하는 기능 : @RequestParam, @ModelAttribute
  - HTTP 메시지 바디를 직접 조회하는 기능 : @RequestBody
- @ResponseBody
  - @ResponseBody를 사용하면 응답 결과를 HTTP 메시지 바디에 직접 담아서 전달할 수 있다.

### HTTP 요청 메시지 - JSON
- HTTP 메시지 바디의 데이터 읽기
  - HttpServletRequest를 직접 사용 (방법1)
    - HTTP 메시지 바디에서 데이터를 읽어와서, 문자로 변환한다.
    - 문자로 된 JSON 데이터를 Jackson 라이브러리인 objectMapper를 사용해서 자바 객체로 변환한다.
  - @RequestBody 문자 반환 (방법2)
    - HTTP 메시지에서 데이터를 꺼내고 messageBody에 저장한다.
    - 문자로 된 JSON 데이터인 messageBody를 objectMapper를 통해서 자바 객체로 변환한다.
  - @RequestBody 객체 반환 (방법3)
    - @RequestBody HelloData data
    - @RequestBody에 직접 만든 객체를 지정할 수 있다.
  - HttpEntity, @RequestBody를 사용하면 HTTP 메시지 컨버터가 HTTP 메시지 바디의 내용을 우리가 원하는 문자나 객체 등으로 변환해준다.
  - HTTP 메시지 컨버터는 문자뿐만 아니라 JSON도 객체로 변환해주는데, 우리가 방금 V2에서 했던 작업을 대신 처리해준다.
  - @RequestBody는 생략 불가능
    - 이 경우에 HelloData에 @RequestBody를 생략하면 @ModelAttribute가 적용되어버린다.
    - 따라서 생략하면 HTTP 메시지 바디가 아니라 요청 파라미터를 처리하게 된다.
- 참고
    - 바이트 코드 : JVM 등의 가상 머신이 이해할 수 있는 언어(코드)
    - 바이너리 코드 : 컴퓨터가 인식할 수 있는 0과 1로 구성된 이진코드
    - Frame : HTTP/2 통신상의 제일 작은 정보의 단위이며, Header 혹은 Data 둘 중 하나
    - Message : HTTP1.1과 마찬가지로 요청 혹은 응답의 단위이며, 다수의 Frame으로 이루어짐
    - Stream : 클라이언트와 서버 사이에 맺어진 연결을 통해 양방향으로 주고받는 하나 혹은 복수개의 Message
        - https://brunch.co.kr/@sangjinkang/3

### HTTP 응답 - 정적 리소스, 뷰 템플릿
응답 데이터는 이미 앞에서 일부 다룬 내용들이지만, 응답 부분에 초점을 맞추어서 정리해보자.
스프링(서버)에서 응답 데이터를 만드는 방법은 크게 3가지이다. (요청도 3가지)
- 정적 리소스
  - 예) 웹 브라우저에 정적인 HTML, css, js를 제공할 때는 정적 리소스를 사용한다.
  - 스프링 부트는 클래스패스의 다음 디렉토리에 있는 정적 리소스를 제공한다.
    - /static, /public, /resources, /META-INF/resources
    - src/main/resources는 리소스를 보관하는 곳이고, 또 클래스패스의 시작 경로이다. 따라서 다음 디렉토리에 리소스를 넣어두면 스플이 부트가 정적 리소스로 서비스를 제공한다.
- 뷰 템플릿 사용
  - 예) 웹 브라우저에 동적인 HTML을 제공할 때는 뷰 템플릿을 사용한다.
  - 뷰 템플릿을 거쳐서 HTML이 생성되고, 뷰가 응답을 만들어서 전달한다.
  - 일반적으로 HTML을 동적으로 생성하는 용도로 사용하지만, 다른 것들도 가능하다. 뷰 템플릿이 만들 수 있는 것이라면 뭐든지 가능하다.
- HTTP 응답 - HTTP API, 메시지 바디에 직접 입력
  - HTTP API를 제공하는 경우에는 HTML이 아니라 데이터를 전달해야 하므로, HTTP 메시지 바디에 JSON 같은 형식으로 데이터를 실어보낸다.
  - 참고
    - HTML이나 뷰 템플릿을 사용해도 HTTP 응답 메시지 바디에 HTML 데이터가 담겨서 전달된다.
    - 여기서 설명하는 내용은 정적 리소스나 뷰 템플릿을 거치지 않고 직접 HTTP 응답 메시지를 전달하는 경우를 말한다.

### HTTP 메시지 컨버터
뷰 템플릿으로 HTML을 생성해서 응답하는 것이 아니라, HTTP API처럼 JSON 데이터를 
HTTP 메시지 바디에서 직접 읽거나 쓰는 경우 HTTP 메시지 컨버터를 사용하면 편리하다.
![MESSAGE_CONVERTER](https://github.com/keunoh/spring-core-theory/assets/96904103/4b3cac58-45b4-4d71-ba6b-4a74ece4ae95)
- @ResponseBody를 사용
  - HTTP의 BODY에 문자 내용을 직접 반환
  - viewResolver 대신에 HttpMessageConverter가 동작
  - 기본 문자처리 : StringHttpMessageConverter
  - 기본 객체처리 : MappingJackson2HttpMessageConverter
  - byte 처리 등등 기타 여러 HttpMessageConverter가 기본으로 등록되어 있음
- 스프링 MVC는 다음의 경우에 HTTP 메시지 컨버터를 적용한다.
  - HTTP 요청 : @RequestBody, HttpEntity(RequestEntity)
  - HTTP 응답 : @ResponseBody, HttpEntity(ResponseEntity)
  - 스프링 부트는 다양한 메시지 컨버터를 제공하는데, 대상 클래스 타입과 미디어 타입 둘을 체크해서 사용여부를 결정한다.
  - 만약 만족하지 않으면 다음 메시지 컨버터로 우선순위가 넘어간다.
  - 몇 가지 주요한 메시지 컨버터
    - ByteArrayHttpMessageConverter : byte[] 데이터를 처리한다.
      - 클래스 타입 : byte[], 미디어타입: */*
      - 요청 예) @RequestBody byte[] data
      - 응답 예) @ResponseBody return byte[], 쓰기 미디어타입 : application/octet-stream
    - StringHttpMessageConverter : String 문자로 데이터를 처리한다.
      - 클래스 타입 : String, 미디어타입: */*
      - 요청 예) @RequestBody String data
      - 응답 예) @ResponseBody return "ok", 쓰기 미디어타입 : text/plain
    - MappingJackson2HttpMessageConverter : application/json
      - 클래스 타입 : 객체 또는 HashMap, 미디어타입: application/json 관련
      - 요청 예) @RequestBody HelloData data
      - 응답 예) @ResponseBody return helloData, 쓰기 미디어타입 : application/json 관련

### 요청 매핑 핸들러 어댑터 구조
그렇다면 HTTP 메시지 컨버터는 스프링 MVC 어디쯤에서 사용되는 것일까?
모든 비밀은 애노테이션 기반의 컨트롤러, 그러니까 @RequestMapping을 처리하는 핸들러 어댑터인
RequestMappingHandlerAdapter(요청 매핑 핸들러 어댑터)에 있다.
![Req_Map_HANDLER_ADAPTER](https://github.com/keunoh/spring-core-theory/assets/96904103/454a507a-44dc-4ef6-8f36-7ba3e971263b)
- ArgumentResolver  
생각해보면, 애노테이션 기반의 컨트롤러는 매우 다양한 파라미터를 사용할 수 있었다.
HttpServletRequest, Model은 물론이고, @RequestParam, @ModelAttribute 같은 애노테이션
그리고 @RequestBody, HttpEntity 같은 HTTP 메시지를 처리하는 부분까지 매우 큰 유연함을 보여주었다.
이렇게 파라미터를 유연하게 처리할 수 있는 이유가 바로 ArgumentResolver 덕분이다.
애노테이션 기반 컨트롤러를 처리하는 RequestMappingHandlerAdapter는 바로 이 ArgumentResolver를 호출해서
컨트롤러(핸들러)가 필요로 하는 다양한 파라미터의 값(객체)을 생성한다.

### HTTP 메시지 컨버터
HTTP 메시지 컨버터는 어디쯤 있을까?
HTTP 메시지 컨버터를 사용하는 @RequestBody도 컨트롤러가 필요로 하는 파라미터의 값에 사용된다.
![HTTP_MESSAGE_CONVERTER](https://github.com/keunoh/spring-core-theory/assets/96904103/395bfde0-80cb-474e-b4b9-fcb23203ea80)
- 요청의 경우
  - @RequestBody를 처리하는 ArgumentResolver가 있고, HttpEntity를 처리하는 ArgumentResolver가 있다.
  - 이 ArgumentResolver들이 HTTP 메시지 컨버터를 사용해서 필요한 객체를 생성하는 것이다.
- 응답의 경우
  - @ResponseBody와 HttpEntity를 처리하는 ReturnValueHandler가 있다. 그리고 여기에서 HTTP 메시지 컨버터를 호출해서 응답 결과를 만든다.

### PRG Post/Redirect/Get
- 사실 지금까지 진행한 상품 등록 처리 컨트롤러는 심각한 문제가 있다.
  - 상품 등록을 완료하고 웹 브라우저의 새로고침 버튼을 클릭해보자.
  - 상품이 계속해서 중복 등록되는 것을 확인할 수 있다.
  
![PROBLEM_PROCESS](https://github.com/keunoh/spring-core-theory/assets/96904103/90ae2166-d5ce-4b78-b5a7-2cef289139f3)
![PROBLEM_PROCESS2](https://github.com/keunoh/spring-core-theory/assets/96904103/8f044495-becd-4755-9048-d83a507bc0e4)
- 웹 브라우저의 새로 고침은 마지막에 서버에 전송한 데이터를 다시 전송한다.
  - 상품 등록 폼에서 데이터를 입력하고 저장을 선택하면 POST /add + 상품 데이터를 서버로 전송한다.
  - 이 상태에서 새로 고침을 또 선택하면 마지막에 전송한 POST /add + 상품 데이터를 서버로 다시 전송하게 된다.
  - 그래서 내용은 같고, ID만 다른 상품 데이터가 계속 쌓이게 된다.
  - 이 문제를 어떻게 해결할 수 있을까? 다음 그림을 보자.

![SOLVED_PROCESS](https://github.com/keunoh/spring-core-theory/assets/96904103/f3cfded3-db45-4084-b841-5472e0d66594)
- 웹 브라우저의 새로 고침은 마지막에 서버에 전송한 데이터를 다시 전송한다.
  - 새로 고침 문제를 해결하려면 상품 저장 후에 뷰 템플릿으로 이동하는 것이 아니라, 상품 상세 화면으로 `리다이렉트`를 호출해주면 된다.
  - 웹 브라우저는 리다이렉트의 영향으로 상품 저장 후에 실제 상품 상세 화면으로 다시 이동한다.
  - 따라서 마지막에 호출한 내용이 상품 상세 화면인 GET /items/{id}가 되는 것이다.
  - 이후 새로고침을 해도 상품 상세 화면으로 이동하게 되므로 새로 고침 문제를 해결할 수 있다.
  - 상품 등록 처리 이후에 뷰 템플릿이 아니라 상품 상세 화면으로 리다이렉트 하도록 코드를 작성해보자.
  - 이런 문제 해결 방식을 PRG Post/Redirect/Get라 한다.
- 주의
  - "redirect:/basic/items/" + item.getId() redirect에서 + item.getId()처럼 URL에 변수를 더해서 사용하는 것은 URL 인코딩이 안되기 때문에 위험하다.
  - 다음에 설명하는 RedirectAttributes를 사용하자
- RedirectAttributes
  - RedirectAttributes를 사용하면 URL 인코딩도 해주고, pathVariable, 쿼리 파라미터까지 처리해준다.
  - redirect:/basic/items/{itemId}
    - pathVariable 바인딩 : {itemId}
    - 나머지는 쿼리 파라미터로 처리: ?status=true

# SPRING MVC 2 - 백엔드 웹 개발 활용 기술
### 타임리프 - 기본 기능
- 타임리프 특징
  - 서버 사이드 HTML 렌더링 (SSR)
    - 타임리프는 백엔드 서버에서 HTML을 동적으로 렌더링하는 용도로 사용된다.
  - 네츄럴 템플릿
    - 타림리프는 순수 HTML을 최대한 유지하는 특징이 있다.
    - 타임리프로 작성한 파일은 HTML을 유지하기 때문에 웹 브라우저에서 파일을 직접 열어도 내용을 확인할 수 있고, 서버를 통해 뷰 템플릿을 거치면 동적으로 변경된 결과를 확인할 수 있다.
    - JSP를 포함한 다른 뷰 템플릿들은 해당 파일을 열면, 예를 들어서 JSP 파일 자체를 그대로 웹 브라우저에서 열어보면 JSP 소스코드와 HTML이 뒤죽박죽 섞여서 웹 브라우저에서 정상적인 HTML 결과를 확인할 수 없다.
    - 오직 서버를 통해서 JSP가 렌더링 되고 HTML 응답 결과를 받아야 화면을 확인할 수 있다.
    - 반면에 타임리프로 작성된 파일은 해당 파일을 그대로 웹 브라우저에서 열어도 정상적힌 HTML 결과를 확인할 수 있다.
    - 물론 이 경우 동적으로 결과가 렌더링 되지는 않는다.
    - 하지만 HTML 마크업 결과가 어떻게 되는지 파일만 열어도 바로 확인할 수 있다.
    - 이렇게 *순수 HTML을 그대로 유지하면서 뷰 템플릿도 사용할 수 있는 타임리프의 특징을 네츄럴 템플릿(Natural Template)*이라 한다.
  - 스프링 통합 지원
    - 타임리프는 스프링과 자연스럽게 통합되고, 스프링의 다양한 기능을 편리하게 사용할 수 있게 지원한다.
- 텍스트 - text, utext
  - 타임리프의 가장 기본 기능인 텍스트를 출력하는 기능을 먼저 알아보자.
    - 타임리프는 기본적으로 HTML 태그의 속성에 기능을 정의해서 동작한다. HTML의 콘텐츠(Content)에 데이터를 출력할때는 다음과 같이 th:text를 사용하면 된다.
    - HTML 태그의 속성이 아니라 HTML 콘텐츠 영역안에서 직접 데이터를 출력하고 싶으면 다음과 같이 [[...]]를 사용하면 된다.
  - Escape, UnEscape
    - HTML 문서는 <, > 같은 특수 문자를 기반으로 정의된다. 따라서 뷰 템플릿으로 HTML 화면을 생성할 때는 출력하는 데이터에 이러한 특수 문자가 있는 것을 주의해서 사용해야 한다.
    - UnEscape는 문자 그대로 <, > 인식해서 HTML로 표현한다 ex) &lt;b>Spring&lt;/b> -> *Spring*
  - HTML 엔티티
    - 웹 브라우저는 <를 HTML 태그의 시작으로 인식한다. 따라서 <를 태그의 시작이 아니라 문자로 표현할 수 있는 방법이 필요한데, 이것을 HTML 엔티티라 한다.
    - 이렇게 HTML에서 사용하는 특수 문자를 HTML 엔티티로 변경하는 것을 이스케이프(ESCAPE)라 한다.
    - 그리고 타임리프가 제공하는 th:text, [[...]]는 *기본적으로 이스케이프(ESCAPE)를 제공*한다.
- 유틸리티 객체와 날짜
  - 타임리프 유틸리티 객체 : https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#expression-utility-objects
  - 유틸리티 객체 예시 : https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#appendix-b-expression-utility-objects
- URL 링크
  - 단순한 URL
    - @{/hello} -> /hello
  - 쿼리 파라미터
    - @{/hello(param1=${param1}, param2=${param2})}
      - /hello?param1=data1&param2=data2
      - ()에 있는 부분은 쿼리 파라미터로 처리된다.
  - 경로 변수
    - @{/hello/{param1}/{param2}(param1=${param1}, param2=${param2})}
    - /hello/data1/data2
    - URL 경로상에 변수가 있으면 () 부분은 경로 변수로 처리된다.
  - 경로 변수 + 쿼리 파라미터
    - @{/hello/{param1}(param1=${param1}, param2=${param2})}
      - /hello/data1?param2=data2
      - 경로 변수와 쿼리 파라미터를 함께 사용할 수 있다.
  - 상대경로, 절대경로, 프로토콜 기준을 표현할 수도 있다.
    - /hello : 절대 경로
    - hello : 상대 경로
    - 참고: https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html#link-urls
- 리터럴
  - 리터럴은 소스 코드상에 고정된 값을 말하는 용어이다.
    - String a = "Hello", int a = 10 + 20
  - 타임리프에서 문자 리터럴은 항상 '(작은 따옴표)로 감싸야 한다.
  - 그러나 문자를 항상 '로 감싸는 것은 너무 귀찮은 일ㅇ디ㅏ. 공백없이 쭉 이어진다면 하나의 의미있는 토큰으로 인지해서 다음과 같이 작은 따옴표를 생략할 수 있다.
    - 룰: A-Z, a-z, 0-9, [], ., -, _
  - 오류
    - `<span th:text="hello world!"></span>`
    - 문자 리터럴은 원칙상 '로 감싸야 한다. 중간에 공백이 있어서 하나의 의미있는 토큰으로도 인식되지 않는다.
  - 리터럴 대체(Literal substitutions)
    - `<span th:text="|hello ${data}|">`
    - 리터럴 대체 문법을 사용하면 마치 템플릿을 사용하는 것처럼 편리하다.
- 속성 설정
  - th:* 속성을 지정하면 타임리프는 기존 속성을 th:*로 지정한 속성으로 대체한다. 기존 속성이 없다면 새로 만든다.
    - HTML에서는 `<input type="checkbox" name="active" checked="false">` -> 이 경우에도 checked 속성이 있기 때문에 checked 처리가 되어 버린다.
    - HTML에서 checked 속성은 checked 속성의 값과 상관없이 checked 라는 속성만 있어도 체크가 된다. 이런 부분이 true, false 값을 주로 사용하는 개발자 입장에서는 불편하다.
    - 타임리프의 th:checked는 값이 false인 경우 checked 속성 자체를 제거한다. 그래서 편리하게 이용이 가능하다.
- 템플릿 레이아웃
  - 이전에는 일부 코드 조각을 가지고와서 사용했다면, 이번에는 개념을 더 확장해서 코드 조각을 레이아웃에 넘겨서 사용하는 방법에 대해서 알아보자.
  - common_header(~{::title}, ~{::link}) 이 부분이 핵심이다.
    - ::title은 현재 페이지의 title 태그들을 전달한다.
    - ::link는 현재 페이지의 link 태그들을 전달한다.

### 타임리프 - 스프링 통합과 폼
타임리프는 스프링 없이도 동작하지만, 스프링과 통합을 위한 다양한 기능을 편리하게 제공한다.
그리고 이런 부분은 스프링으로 백엔드를 개발하는 개발자 입장에서 타임리프를 선택하는 하나의 이유가 된다.
- 스프링 통합으로 추가되는 기능들
  - 스프링의 SpringEL 문법 통합
  - ${@myBean.doSomething()} 처럼 스프링 빈 호출 지원
  - 편리한 폼 관리를 위한 추가 속성
    - th:object (기능 강화, 폼 커맨드 객체 선택)
    - th:field, th:errors, th:errorclass
  - 폼 컴포넌트 기능
    - checkbox, radio button, List 등을 편리하게 사용할 수 있는 기능 지원
  - 스프링의 메시지, 국제화 기능의 편리한 통합
  - 스프링의 검증, 오류 처리 통합
  - 스프링의 변환 서비스 통합(ConversionSerivce)
- 입력 폼 처리
  - th:object : 커맨드 객체를 지정한다.
    - th:object="${item}" : <form>에서 사용할 객체를 지정한다. 선택 변수 식을 적용할 수 있다.
  - *{...} : 선택 변수 식이라고 한다. th:object 에서 선택한 객체에 접근한다.
  - th:field
    - HTML 태그의 id, name, value 속성을 자동으로 처리해준다.
    - th:field="*{itemName}"
      - *{itemName}는 선택 변수 식을 사용했는데, ${item.itemName}과 같다. 앞서 th:object로 item을 선택했기 때문에 선택 변수 식을 적용할 수 있다.
      - th:field는 id, name, value 속성을 모두 자동으로 만들어 준다.
        - id : th:field 에서 지정한 변수 이름과 같다. id="itemName"
        - name : th:field 에서 지정한 변수 이름과 같다. name="itemName"
        - value : th:field 에서 지정한 변수의 값을 사용한다. value=""
- 체크박스 1 - 단일
  - 주의 - 체크 박스를 선택하지 않을 때
    - HTML에서 체크 박스를 선택하지 않고 폼을 전송하면 open 이라는 필드 자체가 서버로 전송되지 않는다.
    - 서버에서 Boolean 타입을 찍어보면 결과가 null 인 것을 확인할 수 있다.
    - HTML checkbox는 선택이 안 되면 클라이언트에서 서버로 값 자체를 보내지 않는다. 수정의 경우에는 상황에 따라서 이 방식이 문제가 될 수 있다.
    - 사용자가 의도적으로 체크되어 있던 값을 체크를 해제해도 저장 시 아무 값도 넘어가지 않기 때문에, 서버 구현에 따라서 값이 오지 않은 것으로 판단해서 값을 변경하지 않을 수도 있다.
    - 이런 문제를 해결하기 위해서 스프링 MVC는 약간의 트릭을 사용하는데, 히든 필드를 하나 만들어서 _open처럼 기존 체크 박스 이름 앞에 붙여서 전송하면 체크를 해제했다고 인식할 수 있다.
    - 히든 필드는 항상 전송된다. 따라서 체크를 해제한 경우 여기에서 open은 전송되지 않고, _open만 전송되는데, 이 경우 스프링 MVC는 체크를 해제했다고 판단한다.
  - 타임리프
    - 개발할 때 마다 이렇게 히든 필드를 추가하는 것은 상당히 번거롭다. 타임리프가 제공하는 폼 기능을 사용하면 이런 부분을 자동으로 처리할 수 있다.
    - 타임리프를 사용하면 체크 박스의 히든 필드와 관련된 부분도 함께 해결해준다. HTML 생성 결과를 보면 히든 필드 부분이 자동으로 생성되어 있다.
  - 타임리프의 체크 확인
    - checked="checked"
    - 체크 박스에스 판매 여부를 선택해서 저장하면, 조회시에 checked 속성이 추가 된 것을 확인할 수 있다.
    - 이런 부분을 개발자가 직접 처리하려면 상당히 번거롭다. 타임리프의 th:field를 사용하면 값이 true인 경우 체크를 자동으로 처리해 준다.
  - @ModelAttribute의 특별한 사용법
    - 등록 폼, 상세화면, 수정 폼에서 모두 서울, 부산, 제주라는 체크 박스를 반복해서 보여주어야 한다.
    - 이렇게 하려면 각각의 컨트롤러에서 model.addAttribute(...)을 사용해서 체크 박스를 구성하는 데이터를 반복해서 넣어주어야 한다.
    - @ModelAttribute는 이렇게 컨트롤러에 있는 별도의 메서드에 적용할 수 있다. [메서드 레벨에서 Annotation 추가]
    - 이렇게하면 해당 컨트롤러를 요청할 때 regions에서 반환한 값이 자동으로 모델(model)에 담기게 된다.

### 메시지, 국제화
- 스프링 메시지 소스 설정
  - 스프링 부트를 사용하면 스프링 부트가 MessageSource를 자동으로 스프링 빈으로 등록한다.
    - 스프링 부트 메시지 소스 기본 값 : spring.messages.basename=messages

### 검증1 - Validation
- 컨트롤러의 중요한 역할중 하나는 HTTP 요청이 정상인지 검증하는 것이다. 그리고 정상 로직보다 이런 검증 로직을 잘 개발하는 것이 어쩌면 더 어려울 수 있다.
  - 참고 : 클라이언트 검증, 서버 검증
    - 클라이언트 검증은 조작할 수 있으므로 보안에 취약하다.
    - 서버만으로 검증하면, 즉각적인 고객 사용성이 부족해진다.
    - 둘을 적절히 섞어서 사용하되, 최종적으로 서버 검증은 필수
    - API 방식을 사용하면 API 스펙을 잘 정의해서 검증 오류를 API 응답 결과에 잘 남겨주어야 함.
  - 검증 직접 처리
    ![image](https://github.com/keunoh/spring-core-theory/assets/96904103/55c7db98-0269-468b-981b-c6fbca29ae73)
- BindingResult
  - FieldError - 필드 오류
  - ObjectError - 글로벌 오류
  - 주의
    - BindingResult 파라미터의 위치는 @ModelAttribute Item item 다음에 와야한다.
    - 즉, 검증할 대상 바로 다음에 와야한다.
  - BindingResult가 있으면 @ModelAttribute에 데이터 바인딩 시 오류가 발생해도 컨트롤러가 호출된다.
  - BindingResult에 검증 오류를 적용하는 3가지 방법
    - @ModelAttribute의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이 FieldError 생성해서 BindingResult에 넣어준다.
    - 개발자가 직접 넣어준다.
    - Validator 사용
- 오류 코드와 메시지 처리
  - 단순하게 만들면 범용성이 좋아서 여러곳에서 사용할 수 있지만, 메시지를 세밀하게 작성하기 어렵다.
  - 반대로 너무 자세하게 만들면 범용성이 떨어진다. 
  - 가장 좋은 방법은 범용성으로 사용하다가, 세밀하게 작성해야 하는 경우에는 세밀한 내용이 적용되도록 메시지에 `단계`를 두는 방법이다.

### Bean Validation
- Form 전송 객체 분리
  - 폼 데이터 전달에 Item 도메인 객체 사용
    - HTML Form -> Item -> Controller -> Item -> Repository
      - 장점 : Item 도메인 객체를 컨트롤러, 리포지토리 까지 직접 전달해서 중간에 Item을 만드는 과정이 없어서 간단하다.
      - 단점 : 간단한 경우에만 적용할 수 있다. 수정시 검증이 중복될 수 있고, groups를 사용해야 한다.
  - 폼 데이터 전달을 위한 별도의 객체 사용
    - HTML Form -> ItemSaveForm -> Controller -> Item 생성 -> Repository
      - 장점 : 전송하는 폼 데이터가 복잡해도 거기에 맞춘 별도의 폼 객체를 사용해서 데이터를 전달 받을 수 있다. 보통 등록과 수정용으로 별도의 폼 객체를 만들기 때문에 검증이 중복되지 않는다.
      - 단점 : 폼 데이터를 기반으로 컨트롤러에서 Item 객체를 생성하는 변환 과정이 추가된다.
- HTTP 메시지 컨터버
  - @Valid, @Validated는 HttpMessageConverter(@RequestBody)에도 적용할 수 있다.
  - API 경우 3가지 경우를 나누어 생각해야 한다.
    - 성공 요청: 성공
    - 실패 요청 : JSON을 객체로 생성하는 것 자체가 실패
    - 검증 오류 요청 : JSON을 객체로 생성하는 것은 성공했고, 검증에서 실패함

### 로그인 처리 - 쿠키, 세션
- 쿠키와 보안 문제
  - 쿠키 값은 임의로 변경할 수 있다.
    - 클라이언트가 쿠키를 강제로 변경하면 다른 사용자가 된다.
  - 쿠키에 보관된 정보는 훔쳐갈 수 있다.
  - 해커가 쿠키를 한번 훔쳐가면 평생 사용할 수 있다.
  - 대안
    - 쿠키에 중요한 값을 노출하지 않고, 사용자 별로 예측 불가능한 임의의 토큰(랜덤 값)을 노출하고, 서버에서 토큰과 사용자 id를 매핑해서 인식한다. 그리고 서버에서 토큰을 관리한다.
    - 토큰은 해커가 임의의 값을 넣어도 찾을 수 없도록 예상 불가능해야 한다.
    - 해커가 토큰을 털어가도 시간이 지나면 사용할 수 없도록 해당 토큰의 만료시간을 짧게(예:30분)유지한다. 또는 해킹이 의심되는 경우 서버에서 해당 토큰을 강제로 제거하면 된다.
- 로그인 처리하기 - 세션 동작 방식
  - 세션 ID를 생성하는데, 추정 불가능 해야한다.
  - UUID는 추정이 불가능하다. 
  - 클라이언트와 서버는 결국 쿠키로 연결이 되어야 한다.
  - 중요
    - 여기서 중요한 포인트는 회원과 관련된 정보는 전혀 클라이언트에 전달하지 않는다는 것이다.

![SESSION_LOGIN](https://github.com/keunoh/spring-core-theory/assets/96904103/11bb413e-1c86-4836-9121-275f96946233)

### 로그인 처리 - 필터, 인터셉터
이러한 공통 관심사는 스프링의 AOP로도 해결할 수 있지만, 웹과 관련된 공통 관심사는 지금부터 설명할
서블릿 필터 또는 스프링 인터셉터를 사용하는 것이 좋다. 
웹과 관련된 공통 관심사를 처리할 때는 HTTP의 헤더나 URL의 정보들이 필요한데, 서블릿 필터나 스프링 인터셉터는 HttpSevletReuqest를 제공한다.
- 필터 흐름
  - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러
  - 필터 제한
    - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 컨트롤러 [ 로그인 사용자 ]
    - HTTP 요청 -> WAS -> 필터(적절하지 않은 요청이라 판단, 서블릿 호출 X) [ 비로그인 사용자 ]
- 스프링 인터셉터 흐름
  - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러
  - 스프링 인터셉터 제한
    - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터 -> 컨트롤러 [ 로그인 사용자 ]
    - HTTP 요청 -> WAS -> 필터 -> 서블릿 -> 스프링 인터셉터(적절하지 않은 요청이라 판단, 컨트롤러 호출 X) [ 비로그인 사용자 ] 

![SPRING_INTERCEPTOR_EXCEPTION](https://github.com/keunoh/spring-core-theory/assets/96904103/18cfad5f-e5eb-4e6c-8e39-269baac1181d)
- 예외가 발생시
  - preHandle: 컨트롤러 호출 전에 호출된다.
  - postHandle: 컨트롤러에서 예외가 발생하면 postHandle은 호출되지 않는다.
  - afterCompletion: afterCompletion은 항상 호출된다. 이 경우 예외를 파라미터로 받아서 어떤 예외가 발생했는지 로그로 출력할 수 있다.
- 정리
  - 인터셉터는 스프링 MVC 구조에 특화된 필터 기능을 제공한다고 이해하면 된다. 스프링 MVC를 사용하고, 특별히 필터를 꼭 사용해야 하는 상황이 아니라면 인터셉터를 사용하는 것이 더 편리하다.